[{"title":"微信小程序和移动网页的相爱相杀","url":"/blog/小程序/微信小程序和移动网页的相爱相杀/","content":"\n两者身为同一个时代的产物，存在太多志同道合、“异性相吸”的魔力，又有着不拘一格、“同性相斥”的魅力。但可以确定的是，两者身上都有一种为了实现世界统一的魄力。\n\n## 生死之战\n\n| pk 项 | h5 | mp-weixin |\n|:---- | ---- | --- |\n| 运行环境 | 浏览器 | 微信 |\n| 系统API权限 | 弱 | 强 |\n| 分享朋友圈 | 能 | 不能 |\n| 扫码识别 | 能 | 能 |\n| 支付能力 | 多种 | 微信支付 |\n| 使用流畅/平滑 | 一般 | 良好 |\n| 入口数量 | 少 | 多 |\n| 专属入口 | 无 | 有 |\n| 简易功能成本 | 低 | 低 |\n| 系统功能成本 | 高 | 低 |\n| 迭代周期 | 短 | 较长 |\n| 外部限制 | 较少 | 多 |\n\n\n## 跨界合作\n\n### 准备工作\n\n1. 注册小程序账号必须为企业的，个人类型的小程序暂不支持使用\n2. 微信 6.7.2 版本以上(目前安卓最新版 7.0.12/苹果 7.0.11)\n3. 需登录小程序管理后台配置业务域名\n4. 基础库1.6.4以上\n\n### 命令部署\n\n1. 业务域名中配置的就是小程序以及 H5 和 H5 中引用 iframe 的域名\n2. 将校验文件放置在将要嵌套的业务域名的根目录\n\n### 统一战线\n\n1. 嵌入的 h5 不能调用支付接口\n2. 嵌入的 h5 拿不到分享成功失败的信息\n\n### 互帮互助\n\n1. mp -> h5  使用 `src ` 地址传值\n2. h5 -> mp `postMessage`, `web-view` 绑定 `bindmessage` 进行接收\n3. weixinjssdk\n\n> tips: `bindMessage`为网页向小程序 `postMessage ` 时，会在特定时机（小程序后退、组件销毁、分享）触发并收到消息\n\n### 矛盾冲突\n\n![](./WX20200318-231151@2x.png)","tags":["小程序"],"categories":["小程序"]},{"title":"text-align 两端对齐","url":"/blog/css/text-align-两端对齐/","content":"### \n## 简单总结\n都知道想实现两端对齐可以使用 `text-align:justify`，但是每次使用或多或少都会出现一些问题。对于这些问题我们就来总结一下\n\n```\ntext-align: justify；\n```\n\n> 兼容性好，能兼容 ios，但只针对非尾行即最后一行之前的文本\n\n```\ntext-align-last: justify；\n```\n\n> 兼容性差，不兼容 ios，只针对尾行的文本\n\n```\nwhite-space: nowrap;\n```\n\n> 设置该属性后不生效\n\n**只有一行的时候那就需要特殊的处理一下了**\n\n1. 使用 `text-align-last`\n2. 手动添加一行最为最后行，并将其隐藏\n\n## 小程序端实现\n\nwxml\n\n```\n<view class=\"foods\">\n   <view class=\"eat\">\n      <view>早上吃什么<text></text></view>: 洗衣粉\n   </view>\n   <view class=\"eat\">\n      <view>午餐呢<text></text></view>: 肥皂\n   </view>\n   <view class=\"eat\">\n      <view>最重要的晚餐<text></text></view>: 沐浴露\n   </view>\n</view>\n```\n\nwxss\n\n```\n.eat {\n   line-height:100rpx\n}\n.eat + .eat {\n   border-top:1rpxsolid #f5f5f5\n}\n.eat view {\n   height:100rpx;\n   width:240rpx;\n   display: inline-block;\n   text-align:justify;\n   vertical-align:top\n}\n.eat view text {\n   display: inline-block;\n   height:0;\n   width:100%  /* 换行 */\n}\n```\n\n\n","tags":["css"],"categories":["css"]},{"title":"mac 创建 svn 仓库","url":"/blog/其他/mac 创建 svn 仓库/","content":"# mac 创建 svn 仓库\n团队开发中代码版本管理是一个必不可少的工具，本篇文章将简单介绍如何在 macOS 中搭建 svn 版本服务\n\n## 安装 svn\n\n### 检查安装\n\n开始之前，先检查系统中是否已经安装了 svn\n\n```\nsvn --version\n```\n\n如果出现版本信息，则表示已经安装成功，可跳过以下安装步骤至创建仓库\n\n### 开始安装\n\n在 macOS 中，一般我建议使用 Homebrew 进行包管理，至于 Homebrew 本篇文章不做描述，不了解的可以自行百度\n\n```\nbrew install svn\n```\n\n安装成功后，建议再检查安装一次，以确保能够正常使用\n\n## 创建仓库\n\n在安装成功之后咱们就可以创建代码仓库了\n\n```\nsvnadmin create ./svn/repository/svn_test\n```\n\n> ./svn/repository/svn_test 为你想存放 svn 仓库的文件地址，svn_test 为当前仓库名称，这里换成你自己的即可\n\n正常情况下，你将可以在你刚刚输入的目录中看到新生成的文件夹了，但是 macOS 升级成 macOS catalina 10.15 后将会出现\n\n```\nzsh: command not found: svnadmin\n```\n\n这个是因为 Apple 在这个版本中移除了 svn 管理，所以导致了 svn 相关的命令失效，这里多说一句 Apple 的这个更新可能会导致一部分的软件需要重新安装，如果遇到了不能正常使用的软件，大家不妨重新安装试一试\n\n## 配置权限\n\n安装成功后，进入到你刚刚设置的目录中，如我们设置的 ./svn/repository/svn_test，你将看见大致（只展示我们需要的部分）如下的目录\n\n```\n|-- conf\n|---- authz\n|---- hooks-env.tmpl\n|---- passwd\n|---- svnserve.conf\n|-- db\n|-- hooks\n|-- locks\n|-- format\n|-- README.txt\n```\n\n### 权限\n打开 conf 下的 svnserve.conf 文件并做以下修改\n\n```\n# anon-access = read\nanon-access = read\n\n# auth-access = write\nauth-access = write\n\n# password-db = passwd\npassword-db = passwd\n\n# authz-db = authz\nauthz-db = authz\n\n```\n\n> 1. 以上修改为上一行为原始配置，下一行为修改后的配置\n> 2. 以上配置信息的含义请自行百度\n\n### 用户\n打开 conf 下的 passwd 文件并做以下修改\n\n```\n[users]\n\nsvnuser1 = 123456\nsvnuser2 = 123456\n```\n> 添加用户名为 svnuser1，密码为 123456 和用户名为 svnuser2，密码为 123456 的两位用户\n\n### 分组授权\n打开 conf 下的 authz 文件并做以下修改\n\n```\n[groups]\nsvngroup = svnuser1,svnuser2\n\n[/]\n@svngroup=rw\n```\n> rw为可读可写\n\n## 启动服务\n返回控制台输入\n\n```\nsvnserve -d -r ./svn/repository\n```\n\n> 这里需要控制所建仓库地址，不需要进行至仓库名称\n\n如果控制台没有报错则说明启动成功\n\n## 连接服务\n启动成功后，我们将远程的代码进行拉去，尽管现在没有代码，我们也可以先将仓库拉下来用于后续代码管理\n\n```\nsvn checkout svn://localhost/svn_test --username=svnuser1 --password=123456 ./code\n```\n\n> 将代码从 svn_test 下载到 ./code 目录下\n\n## 关闭服务\n因为 svn 服务就是一个进程，所以可以通过杀进程的方式进行管理\n\n### 方法一（推荐）：\n\n打开系统软件《活动监视器》 选择 svnserve 进行关闭即可。\n\n### 方法二\n\n获取 svn 的 PID\n\n```\nps -ef|grep svn\n```\n\n杀掉进程\n\n```\nkill -9 $1\n```\n\n> $1 为上面获取到的 PID\n\n## 至此\n这样一个 svn 代码管理仓库就搭建完成了，我们就可以用 svn 来进行我们的代码管理","tags":["svn"],"categories":["其他"]},{"title":"docker 镜像","url":"/blog/其他/docker镜像/","content":"## mysql \n\n### 获取镜像\n\n```\ndocker pull mysql\n```\n\n### 运行容器\n\n```\ndocker run\n-d\n-v $PWD/mysql/conf:/etc/mysql/conf.d\n-v $PWD/mysql/logs:/logs\n-v $PWD/mysql/data:/var/lib/mysql\n-e MYSQL_ROOT_PASSWORD=root\n-p 13306:3306\nmysql\n```\n> $PWD 为当前目录，可当变量使用\n\n>- -d：在后台运行\n>- -p：容器的 3306 端口映射到宿主机 13306\n>- -v：容器的 /etc/mysql/conf.d 配置文件映射到宿主机 $PWD/mysql/conf\n>- -e：mysql root 用户的密码\n\n### navicat连接\n查看加密特性\n\n```\nselect Host,User,plugin from mysql.user;\n```\n\n如出现以下情况\n\n| Host | User | plugin |\n|:-----|:------|:------|\n| % | root | caching_sha2_password |\n\n则执行\n\n```\n ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'root';\n```\n> 最后的`root`为账号密码\n\n设置成功后就可以进行`navicat`连接\n\n## mongodb\n### 获取镜像\n\n```\ndocker pull mongo\n```\n\n### 运行容器\n```\ndocker run \n-d \n-v $PWD/mongodb/db:/data/db \n-p 27017:27017 \n--name mongodb \nmongo\n```\n>- -d：在后台运行\n>- -v：容器的 /data/db 数据配置文件映射到宿主机 $PWD/mongodb/db\n>- -p：容器的 27017 端口映射到宿主机 27017\n>- --name：容器的名字为 mongodb\n\n## jenkins\n### 获取镜像\n```\ndocker pull jenkins/jenkins:lts\n```\n\n### 运行容器\n```\ndocker run \n-d \n-v $PWD/jenkins:/var/jenkins_home \n-p 13050:8080\n--name jenkins \njenkins/jenkins:lts\n```\n> 与上面的说明一致\n\n### 进入容器\n```\ndocker exec -it [CONTAINER ID] /bin/bash\n```\n\n## nginx\n### 获取镜像\n```\ndocker pull nginx\n```\n\n### 运行容器\n\n运行一个简单的 nginx\n\n```\ndocker run -d -p 80:80  --name nginx nginx\n```\n\n将容器中 nginx 的配置文件复制到 . 当前目录下\n\n```\ndocker cp nginx:/etc/nginx .\n```\n\n修改配置文件后即可停止并删除 nginx 服务\n\n```\ndocker stop nginx\ndocker rm nginx\n```\n\n目录映射 ---- 使修改的配置生效\n\n```\ndocker run\n-d\n-v $PWD/nginx/conf:/etc/nginx\n-v $PWD/nginx/html:/usr/share/nginx/html\n-p 80:80\nnginx\n```\n> 与上面的说明一致\n\n## docker常用命令\n```\ndocker images\t\t\t\t\t\t\t// 查看已有的docker镜像\ndocker ps\t\t\t\t\t\t\t\t// 查看所有运行中容器\ndocker ps -a\t\t\t\t\t\t\t// 查看所有状态的容器\ndocker start [ID]       \t\t\t\t// 启动指定ID容器\ndocker stop [ID]\t    \t\t\t\t// 停止指定ID容器\ndocker restart [ID]\t    \t\t\t\t// 重启指定ID容器\ndocker rm [ID]\t\t    \t\t\t\t// 删除指定ID容器\ndocker rmi [NAME]       \t\t\t\t// 删除特定镜像\ndocker exec -it [CONTAINER ID] /bin/bash //进入容器\n\n```","tags":["其他"],"categories":["其他"]},{"url":"/blog/uncategorized/跨页面传值/","content":"跨页面传值\n\n1. postMessage 需要iframe嵌套使用，可解决例外页面跨域的问题\n2. localStorage 需要同一个浏览器的两个页面\n3. websocket 需要服务端支持"},{"title":"uni-app","url":"/blog/混合开发/uni-app踩过的坑/","content":"# 在uni-app进行多端开发总结\n\n## H5\n\n## 非H5\n1. 不可对uni进行属性添加\n2. 不可使用slot属性\n3. 不可上传非图片文件\n\n\n### 微信小程序\n\n### 支付宝小程序\n1. 不可使用高度100%\n2. 需要将导航栏的背景设置成#fff才可以显示标题\n","tags":["uni-app"],"categories":["混合开发"]},{"title":"小程序获取特定页二维码","url":"/blog/小程序/小程序获取特定页二维码/","content":"\n# 准备工作\n1. 确保页面路径存在*app.json*文件中\n2. 获取小程序的*AppId*和*AppSecret*\n3. 下载postman工具\n\n# 开始获取\n\n微信提供了「获取小程序二维码」的接口。\n通过这个接口，商家和开发者能够制作进入不同页面的小程序二维码，而不会限定扫码进入小程序主页。\n\n## 获取Access Token\n\n利用postman工具根据准备的**AppID**和**AppSecret**，获取 **Access Token**。 使用**get**方式请求地址*https://api.weixin.qq.com/cgi-bin/token*，传入以下参数\n\n```\n{\n  grant_type: client_credential,\n  appid: 你的AppId,\n  secret: 你的AppSecret\n}\n```\n\n点击**Send**出现图中所示则表示请求成功，其中**access_token**就是我们需要的值\n\n![](./getAccessToken.png)\n\n## 获取二维码\n\n微信提供了两个**POST**获取小程序二维码的接口\n\n- 获取最新的「菊花式」小程序码，可以使用这个接口：\n\n```\nhttps://api.weixin.qq.com/wxa/getwxacode?access_token=ACCESS_TOKEN。\n```\n\n- 获取经典的「狗皮膏药式」QR 码，可以使用这个接口：\n\n```\nhttps://api.weixin.qq.com/cgi-bin/wxaapp/createwxaqrcode?access_token=ACCESS_TOKEN\n```\n\n在postman中输入以上地址后需要**修改POST请求体中的请求方式为raw, 并修改JSON请求体为**\n\n```\n{\"path\": \"pages/discover/article/index?type=1\"}\n```\n\n最终配置如下\n![](./getQRParams.png)\n![](./getQRBody.png)\n\n如果请求成功则会返回小程序的二维码图片\n\n![](./getSuccess.png)","tags":["微信小程序"],"categories":["小程序"]},{"title":"用vertical-align实现垂直水平居中","url":"/blog/css/verticalAlign简介/","content":"\n# 简介\nvertical-align属于css中用的比较少的一个属性，其原因就是它比较难于理解，但它是同时也是一个比较重要的属性。首先引用一段对它的定义说明\n\n> 该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。允许指定负长度值和百分比值。这会使元素降低而不是升高。在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式。\n\n对此我们得到了两层重要信息\n\n1. **该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐**。注意其中的行内元素，说明该属性**只对行内元素有效**\n2. 表格的**td**中直接添加`vertical-align: middle`的样式让其`垂直居中对齐`，添加`vertical-align: top`顶部对齐。\n\n> **Tips:** 该属性与水平对齐方式属性`text-align`不同，使用对象是linebox下的行内元素\n\n> **什么是Line Box**\n\n> 每一行称为一条Line Box，它又是由这一行的许多inline-box组成，它的高度可以直接由line-height决定，line boxes的高度垂直堆叠形成了containing box的高度，就是我们见到的div或是p标签之类的高度了\n\n# baseline\n[传送门](http://www.cnblogs.com/starof/p/4512284.html?utm_source=tuicool&utm_medium=referral)\n\n# 实际应用\n\n垂直居中\n\n> 为父元素设定一个伪元素`::after`,其高度为父元素的高度并设置`display:inline-block`让其成为lineBox元素,将`::after`设定为`vertical-align:middle`即可撑开lineBox，同时lineBox的baseline为父元素高度一半的位置。然后设定子元素`vertical-align:middle`，即可实现居中。\n\n> 考虑兼容性的话，这里需要使用一些hack，由于IE8不支持::after伪元素，所以需要一个span来替代。而display:inline-block亦需要hack。\n\n代码示例：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        .masker-model {\n            background-color: #000;\n            opacity: .6;\n            z-index: 999;\n            position: fixed;\n            left: 0;\n            right: 0;\n            top: 0;\n            bottom: 0;\n            text-align: center;\n        }\n        .masker-model::after {\n            content: '';\n            display: inline-block;\n            height: 100%;\n            vertical-align: middle;\n        }\n        .loading {\n            color: #fff;\n            display: inline-block;\n            vertical-align: middle;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"masker-model\">\n        <div class=\"loading\">loading....</div>\n    </div>\n</body>\n</html>\n```\n\n\n\n","tags":["css"],"categories":["css"]},{"title":"创建简单的npm脚手架","url":"/blog/服务端/创建简单的npm脚手架/","content":"\n## 前言\nvue-cli， webpack-cli 等脚手架是不是用起来爱不释手？自己写了个模版每次来回复制粘贴代码是不是很难维护？如果你是对前端、Node操作有一定的了解，同时也存在以上疑问，那就请尽情阅读尝试吧！\n\n> 本篇文章按照`al-block-cli`举例, `al-block-cli`是一个基于`vue`和`elementUI`而集成的一个开发模版，可安装进行使用\n\n## 依赖\n\n1. [Commander.js](https://github.com/tj/commander.js) 命令行工具\n2. [download-git-repo](https://github.com/flipxfx/download-git-repo) git仓库代码下载\n3. [chalk](https://github.com/chalk/chalk) 命令行输出样式美化\n4. [Inquirer.js](https://github.com/SBoudrias/Inquirer.js) 命令行交互\n5. [ora](https://github.com/sindresorhus/ora)命令行加载中效果\n\n根据上方的依赖插件即可以看出，**其实脚手架就是一个利用终端命令将仓库中的代码拉取到本地的工具**。*所以还没有模版代码的同学赶紧去创建个*\n\n## 项目准备\n\n### Npm初始化\n\n```\n$ npm init\n```\n\n> 根据提示完成初始化搭建，如果不清楚如何配置可以**直接回车**\n\n### 安装依赖\n\n```\n$ npm install commander download-git-repo chalk inquirer ora --save\n```\n### 构建结构\n\n1. 创建`bin`和`commands`文件夹以及配置文件`templates.json`。\n2. 在`bin`目录下创建入口文件`al-block-cli`，在`commands`目录下创建命令指示文件`init.js`\n\n> `bin`文件夹为可执行命令入口目录，`commands`则负责编写一些命令交互，\n\n### 最终目录结构\n\n```\n- al-block-cli\n| - bin\n  | - al-blocl-cli\n| - commands\n  | - init.js\n| - node_modules\n| - package.json\n| - templates.json\n```\n## 编写代码\n\n### 配置文件\n\n输入默认需要的配置，如这里需要`github `的仓库地址和命令行的名称\n\n```\n{\n  \"init\": {\n    \"name\": \"init\",\n    \"path\": \"Alisdon/al-block-template\"\n  }\n}\n```\n\n### 入口文件\n\n打开`al-block-cli`文件，并在其第一行加入\n\n```\n#! /usr/bin/env node\n```\n> 此行为了防止操作系统用户没有将**node**装在默认的**/usr/bin**路径里。当系统看到这一行的时候，首先会到env设置里查找node的安装路径，再调用对应路径下的解释器程序完成操作。\n\n```\n#!/usr/bin/env node\n\nprocess.env.NODE_PATH = __dirname + '/../node_modules/';\n\nconst program = require('commander');\n\nprogram\n  .version(require('../package').version);\n\nprogram\n  .usage('<command>');\n\nprogram.command('init')\n  .description('create a new project')\n  .alias('i')\n  .action(() => {\n    require('../commands/init')\n  });\n\nprogram.parse(process.argv);\n\nif(!program.args.length){\n  program.help()\n}\n```\n### 命令交互\n\n打开表示命令`init`的`init.js`文件\n\n```\nconst { prompt } = require('inquirer');\nconst program = require('commander');\nconst chalk = require('chalk');\nconst download = require('download-git-repo');\nconst ora = require('ora');\nconst fs = require('fs');\n\nconst option =  program.parse(process.argv).args[0];\nconst question = [\n  {\n    type: 'input',\n    name: 'name',\n    message: 'Project name',\n    default: typeof option === 'string' ? option : 'al-block-template',\n    filter (val) {\n      return val.trim()\n    },\n    validate (val) {\n      const validate = (val.trim().split(\" \")).length === 1;\n      return validate || 'Project name is not allowed to have spaces ';\n    },\n    transformer (val) {\n      return val;\n    }\n  },\n  {\n    type: 'input',\n    name: 'description',\n    message: 'Project description',\n    default: 'Vue project',\n    validate () {\n      return true;\n    },\n    transformer(val) {\n      return val;\n    }\n  },\n  {\n    type: 'input',\n    name: 'author',\n    message: 'Author',\n    default: '',\n    validate () {\n      return true;\n    },\n    transformer(val) {\n      return val;\n    }\n  }\n];\n\nmodule.exports = prompt(question).then(({name, description, author}) => {\n  const gitPlace = require('../templates').init.path;\n  const projectName = name;\n  const spinner = ora('Downloading please wait...');\n\n  spinner.start();\n  download(`${gitPlace}`, `./${projectName}`, (err) => {\n    if (err) {\n      console.log(chalk.red(err));\n      process.exit()\n    }\n\n    fs.readFile(`./${projectName}/package.json`, 'utf8', function (err, data) {\n      if(err) {\n        spinner.stop();\n        console.error(err);\n        return;\n      }\n\n      const packageJson = JSON.parse(data);\n      packageJson.name = name;\n      packageJson.description = description;\n      packageJson.author = author;\n\n      fs.writeFile(`./${projectName}/package.json`, JSON.stringify(packageJson, null, 2), 'utf8', function (err) {\n        if(err) {\n          spinner.stop();\n          console.error(err);\n        } else {\n          spinner.stop();\n          console.log(chalk.green('project init successfully!'))\n          console.log(`\n            ${chalk.yellow(`cd ${name}`)}\n            ${chalk.yellow('npm install')}\n            ${chalk.yellow('npm run dev')}\n          `);\n        }\n      });\n    });\n  })\n});\n\n```\n\n## 测试发布\n\n### 测试\n\n至此，一个简单的脚手架（壳）就已经完成了，为了查看在编写过程中是否出错，我们现在本地进行测试\n\n```\n$ node bin/al-block-cli\n```\n\n如果没有报错，出现了熟悉的命令行，那就说明成功了\n\n### 发布\n\n发布之前我们需要做个小调整，观察其他脚手架工具他们都是以自己独特的`key`值进行搭建，对此我们可以在`package.json`里面配置`bin`对象\n\n```\n\"bin\": {\n\t\"al-block-cli\": \"bin/al-block-cli\"\n}\n```\n\n> 这里需要注意`bin/`后面的`al-block-cli`,这个路径是由[入口文件](#入口文件)的路径确定，如果你是建的`al-block-cli.js`则此处应该配置`bin/al-block-cli.js`，本篇是创建的没有后缀名的文件\n\n修改后生成的最终`package.json`\n\n```\n{\n  \"name\": \"al-block-cli\",\n  \"version\": \"1.0.0\",\n  \"description\": \"al-block-cli\",\n  \"keywords\": [\n    \"vue\",\n    \"al-block\",\n    \"al-block-cli\"\n  ],\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"bin\": {\n    \"al-block-cli\": \"bin/al-block-cli\"\n  },\n  \"preferGlobal\": true,\n  \"author\": \"Alisdon [920124512@qq.com]\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"chalk\": \"^2.4.1\",\n    \"commander\": \"^2.19.0\",\n    \"download-git-repo\": \"^1.1.0\",\n    \"inquirer\": \"^6.2.1\",\n    \"ora\": \"^3.0.0\"\n  }\n}\n```\n\n对比文件内容，如果没有问题我们就开始发布了\n\n```\n$ npm login\n$ npm publish\n```\n\n","tags":["node"],"categories":["服务端"]},{"title":"用于mmzsblog网站博客开发","url":"/blog/mmzsblog/mmzsblog/","content":"\n## 前期准备\n\n以下代码均在系统命令行(*非node环境下的命令行*)下完成。\n\n- `cmd`打开*window系统*命令行\n- 直接在*mac系统*中打开`终端`\n\n### 安装nodeJs\n\n前往 [node官方下载地址](https://nodejs.org/en/download/)下载对应版本进行安装\n\n#### 检测安装状态\n\n```\n$ node -v\n```\n出现版本信息则表示安装成功\n### 安装git\n\n前往 [git官方下载地址](https://git-scm.com/downloads)下载对应版本进行安装\n#### 检测安装状态\n\n```\n$ git --version\n```\n出现版本信息则表示安装成功\n### 安装hexo\n\n```\n$ npm install -g hexo-cli\n```\n> 此步骤需要将`nodejs `安装成功后才可进行，否则将报`npm `命令不存在的错误\n\n#### 检测安装状态\n\n```\n$ hexo version\n```\n出现版本信息则表示安装成功\n\n\n## 克隆代码\n### 克隆框架代码\n\n```\n$ git clone git@118.24.19.22:/mmzsblog/blog.git\n```\n> 此步骤需要将`git`安装成功后才可进行，否则将报`git `命令不存在的错误。后续在**新增文章之前需要先更新框架代码**。拉取成功后默认文件夹名称为`blog`，本篇文章以`blog`为文件夹名称举例\n\n### 克隆主题代码\n\n```\n$ cd blog\n$ git clone git@118.24.19.22:/mmzsblog/theme.git themes/pure\n```\n\n> 此步骤需要将`git`安装成功后才可进行，否则将报`git `命令不存在的错误，由于框架代码中主题代码不能提交成功，所以将其分开获取。此代码只需要拉取一次，后续**新增文章之前可不再更新**\n\n## 安装依赖\n```\n$ npm install\n```\n执行成功上述操作将出现图中目录文件\n![](./hexom.png)\n\n## 开始创建\n### 新建文章\n创建文章之前先更新仓库代码，然后再创建一篇新文章\n\n```\n$ git pull\n$ hexo new 你的文章名称\n```\n\n打开**当前文件夹**下的`source/_post`目录，找到新建的文件*（一般是根据上方新建的文章名称作为文件名称）*进行编写\n\n### 静态图片的处理\n\n1. 放到`source/images`文件中，在文章中需要进行`![](/images/xxx.jpg)`的引入\n2. 直接放到和文章名称相同的文件夹中，在文章中需要进行`![](./xxx.png)`的引入\n\n### 预览文章\n```\n$ hexo server\t\t简写\t\thexo s\n```\n![](./hexos.png)\n\n> 打开浏览器输入`http://localhost:4000`进行访问。如果出现白板且控制台出现了`index.html`相关的问题则是由于没有获取主题导致的，需要前往<a href=\"#克隆主题代码\">克隆主题文件</a>\n\n## 发布文章\n由于`mmzsblog`是通过`github`进行重定向，所以将不做清理静态文件的操作，避免提交后需要重新设置的重复操作\n\n### 打包编译\n```\n$ git pull\n$ hexo generate \t 简写\t\thexo g\n```\n\n![](./hexog.png)\n\n### 发布提交\n```\n$ hexo deploy\t\t 简写\t\thexo d\n```\n\n![](./hexod.png)\n\t\n如果出现以上提示则说明提交成功，隔几分钟后刷新[https://blog.mmzsblog.cn](https://blog.mmzsblog.cn)即可查看刚刚新增的文章\n\t\n## 提交代码\n\n提交框架代码，避免多人开发时不同步的问题\n\n```\n$ git status\n$ git add .\n$ git commit -m '新增一篇文章'\n$ git push\n```","tags":["mmzsblog"],"categories":["mmzsblog"]},{"title":"mac下安装nginx","url":"/blog/服务端/mac 下安装nginx/","content":"\n## 初识nginx\n相信大多数同学已经听说了nginx这个东东，会不会很多同学和我一样一开始接触nginx的时候不知道它是什么？它能干什么？如果需要启服务，完全可以用node，为什么还需要使用nginx？\n\n对以上问题，我先引用一下官方对nginx的介绍\n\n> \"Nginx是一款轻量级的HTTP服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的IO性能，时常用于服务端的反向代理和负载均衡。\"\n\n### nginx的应用场景\n\n 1. **http服务器**。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。\n 2. **虚拟主机**。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。\n 3. **反向代理，负载均衡**。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。\n\n### nginx的优点\nnginx的优点在应用场景中已有体现，比如上面提到的反向代理，负载均衡功能。除此之外还有以下优势\n\n- **支持海量高并发**：采用IO多路复用epoll。官方测试Nginx能够支持5万并发链接，实际生产环境中可以支撑2-4万并发连接数。\n- **内存消耗少**：在主流的服务器中Nginx目前是内存消耗最小的。\n- **配置文件简单**：网络和程序配置通俗易懂，即使非专业运维也能看懂。\n- **支持热部署**：这对于我们前端的同学来说，使用惯webpack的热更新，对热更新的支持，无疑是吸引了一大波同学（我就算其中一个，啊哈哈）\n\n![](/blog/images/nginx-c.jpg)\n\n## 安装nginx\n前面铺垫了这么多，现在终于进入主题了。本教程是使用homebrew进行安装，未安装brew的同学请自行安装\n\n\tbrew install nginx\n\n![](/blog/images/nginx-install.png)\n### 配置文件地址\n安装成功后需要对配置文件进行个性化定制，本教程提供大部分时间需要修改的配置，配置文件在如下地址处\n\n*/usr/local/etc/nginx/nginx.conf*\n\n### 默认根目录\n是否想知道网址访问的哪份文件呢？来，我们一起打开它\n\n*/usr/local/var/www/*\n\n## 启动重启关闭\n成功安装后，我们肯定就是来使用nginx了，你可使用\n\n\tnginx \n\t\n**直接启动**或者使用\n\n\tnginx -s reload|reopen|stop|quit \n\n**重新加载配置|重启|快速停止|安全关闭**\n\n启动成功后，我们就只需要在浏览器中访问服务（地址）就好了\n\n*http://localhost:8080*\n\n![](/blog/images/nginx-open.png)\n\n## 自定义配置\n### 修改访问端口\n默认8080被占用了？或者你看8080端口不爽？来，我们一起灭了它\n\n![](/blog/images/nginx-port.png)\n\n### 修改默认根目录\n修改完8080，你是否觉得用默认的网站根目录很难找？是不是想换成自己熟悉的目录呢？\n\n![](/blog/images/nginx-path.png)\n\n> tips: 配置文件里`location /` 里面的`root`,将`yourname`换成你电脑的用户名\n\n## 异常处理\n### Permission问题\n这种问题都是没有权限引起的，执行代码前加上sudo即可\n\n![](/blog/images/nginx-permission.png)\n\n### Forbidden\n修改了默认的网站根目录，出现问题时避免不了的。但是怎么办呢？这种问题一般是没有找到对应的文件，要不就是权限的问题\n\n1. 查看目录下是否存在`index.html`或者`index.htm`\n\n2. 修改配置文件第一行为 `user root owner;` 然后重启\n\n### File not find\n同上 <a href=\"#Forbidden\"> Forbidden </a>的解决方案\n\n## 卸载nginx\n好了，最后，如果你还是觉得nginx用起来不爽，更喜欢node，Apache什么的，勇敢的卸载它吧\n\n\tbrew uninstall nginx\n","tags":["nginx"],"categories":["服务端"]},{"title":"安装hexo","url":"/blog/其他/安装hexo/","content":"\n### 安装hexo \n\n```\n$ npm install -g hexo-cli\n```\n\n### 初始化项目 \n\n```\n$ hexo init <folder>\n$ cd <folder>\n$ npm install``\n```\n\n### 启动项目 \n```\n$ hexo server\n```\n\n### 更换主题 \n选择喜欢的[主题](https://hexo.io/themes/)并根据选择的主题进行更换，并将_config.yml中的theme主题替换成在文件夹theme中的文件名称, 添加主题中需要的图片等素材","tags":["其他"],"categories":["其他"]},{"title":"hexo书写一篇文章","url":"/blog/其他/用hexo写一篇文章/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate (hexo g)\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy (hexo d)\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["其他"],"categories":["其他"]},{"title":"linux下实现无密操作git","url":"/blog/服务端/linux下实现无密操作git/","content":"\n### linux服务端配置\n\n**linux安装git**\n\n\tyum install -y git\n\n**创建用户git**\n\n\tgroupadd git\n\tadduser git -g git\n\t\n**配置linux权限问题及创建authorized_keys文件**\n\n\tcd /home/git\n\tmkdir .ssh\n\tchmod 700 .ssh\n\ttouch .ssh/authorized_keys\n\tchmod 600 .ssh/authorized_keys\n\tcd /home\n\tchown -R git:git git\n\n\tTips:后续的git clone如果需要密码，很有可能是git用户没有访问authorized_keys文件的权限\n\n**创建git仓库文件夹**\n\n\tcd /home\n\tmkdir gitTest\n\tchown git:git gitTest //赋予git用户权限\n\n**初始化git仓库**\n\n\tcd gitTest\n\tgit init --bare gitTest.git\n\n**把仓库所属用户改为git**\n\n\tchown -R git:git gitTest.git\n\n**创建post-receive文件（若不使用git自启动属性可不操作）**\n\n\tvim ~/gitTest.git/hooks/post-receive\n\n**post-receive文件内容（若不使用git自启动属性可不操作）**\n\n\t#！/bin/sh\n\tgit --work-tree=/usr/share/nginx/html/blog --git-dir=/home/gitTest/gitTest.git checkout -f\n\n**设置权限（若不使用git自启动属性可不操作）**\n\n\tchmod +x ~/gitTest.git/hooks/post-receive\n\n### **创建客户端口令**\n\n\tssh-keygen -t rsa -C '你的邮箱'\n\n### **设置免密登录口令**\n\n将id_rsa.pub中的内容写到服务器的authorized_keys文件中。\n\n\tcat id_rsa.pub >> authorized_keys\n\n\n### **请求git仓库**\n\n\tgit clone git@ip:/home/gitTest/gitTest.git","tags":["git"],"categories":["服务端"]}]