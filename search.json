[{"title":"关于代码质量的一些思考","url":"%2Fblog%2F%E5%85%B6%E4%BB%96%2F%E5%85%B3%E4%BA%8E%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%2F","content":"\n最近一直在思考一个问题, 每次做代码 code review 时, 在内心都会有一个纠结点 - 这段阅读起来十分头痛的代码实现了业务并且平稳运行了, 那这块的代码到底算不算是一段合格的代码? 经过一段时间的反复博弈, 我给出了肯定的答案,  任何的程序都是为了准确无误的运行. 从这一点来说, 这是一段合格的代码, 但是那段代码阅读起来又是如此的难以理解更不用说上手调整, 所以这算不上是一段好质量代码。\n\n## 为什么我们要写一些质量好的代码?\n\n> 场景: \n>\n> 1. 接到一个开发任务 \n> 2. 噼里啪啦开发完成\n> 3. 一周后这个地方可以优化一下, 那个地方存在bug需要修复\n> 4. 一个月后这写的什么东西, 看不懂啊\n> 5. 又一个月后无力维护, 开始甩锅\n\n针对这一个场景, 可能有些夸张, 毕竟拿了老板的钱就需要帮老板排忧解难, 怎么能甩锅呢? 可以拿《世界很大, 我想去看看》的理由和老板‘协商’嘛! \n\n而这种情况其实我是亲身经历过的, 当然我说的是前面那部分, 到看不懂自己写的代码哪儿截止。但是不难看出, 代码不仅仅只是为了运行起来, 还需要考虑后期的维护。\n\n> 场景:\n>\n> 1. 接到一个功能迭代任务\n> 2. 打开并开始阅读第一个函数代码\n> 3. 找到了需要改动的代码, 开始输入了第一行代码\n> 4. 又删除了输入的代码, 并进入了另外一个函数\n> 5. 又开始输入代码, 输入一半, 又删除了输入代码\n> 6. 回到了最初改动代码的位置, 将代码做了还原\n> 7. 打开新的窗口继续查看\n\n我们在修改代码的时候, 首先需要做的就是阅读理解已有代码(废话), 当遇到一段难以理解维护的代码时, 无疑会增加你的阅读时间, 这样你的投入时间越多, 性价比就越低。 而往往在多人合作开发中, 阅读已有代码这是一个不可避免的存在, 所以我们更加需要去写一些高质量的代码让我们的代码变得可读、易读。 \n\n## 什么样的代码才算是好质量代码?\n\n通过上面的两个场景, 我们已经对高质量代码的重要性有了一个共同的认识, 那么什么样的代码才算是高质量代码呢? \n\n在软件质量评价标准中对影响软件质量的定义提到了以下特性\n\n> - 可理解性(‘我能理解它吗?’)\n>\n> - 可维护性(‘我能修复它吗?’)\n>\n> - 灵活性(‘我能改变它吗?’)\n>\n> - 可测试性(‘我能测试它吗?’)\n>\n> - 可移植性(‘我能在另外一台机器上运行它吗?’)\n>\n> - 可重用性(‘我能再用它的某些部分吗?’)\n>\n> - 互运行性(‘我能把它和另外一个系统结合吗?’)\n>\n> - 正确性(‘它按照我的需求工作吗?’)\n>\n> - 健壮性(‘对意外环境它能适当适应吗?’)\n>\n> - 效率(‘完成预定功能时它需要的计算机资源多吗?’)\n>\n> - 完整性(‘它是安全的吗?’)\n>\n> - 可用性(‘我能使用它吗?’)\n>\n> - 风险性(‘能按预定计划完成它吗?’)\n\n同时在《代码整洁之道》中关于什么是整洁代码一段中, 作者询问了一些非常知名且经验丰富的程序员\n\n> - **C++ 语言发明者 - Bjarne Stroustrup**\n>\n>   我喜欢优雅和高效的代码。代码逻辑应该直接了当，叫缺陷难以隐藏；尽量减少依赖关系，使之便于维护；依据某种分层战略完善错误处理代码。性能调制最优，省的引诱别人做没规矩的优化，搞出一堆混乱来。整洁的代码只做好一件事。\n>\n> - **《面向对象设计与分析》作者 -  Grady Booch**\n>\n>   简洁的代码简单直接。简洁的代码如同优美的散文。简洁的代码从不隐藏设计者的意图，充满了干净利落的抽象和直接了当的控制语句。\n>\n> - **OTI公司创始人、Eclipse 战略教父 - Dave Thomas**\n>\n>   整洁的代码应可由作者之外的开发者阅读和增补。它应有单元测试和验收测试。它使用有意义的命名。它只提供一种而非多种做一件事的途径。它只有尽量少的依赖关系，而且要明确地定义和提供清晰、尽量少的API。代码应通过其字面表达含义，因为不同的语言导致并非所有必须信息均可通过代码自身清晰表达。\n>\n> - **《修改代码的艺术》作者 - Michael Feathers**\n>\n>   我可以列出我留意到的简洁代码的所有优点，但其中有一条是根本性的。简洁的代码总是看起来像是某位特别在意它的人写的。几乎没有改进的余地，代码作者几乎什么都想到了，如果你企图改进他，总会回到原点，赞叹某人留给你的代码–全心投入的某人留给你的代码。\n>\n> - **《极限编程实施》、《C#极限编程探险》作者 - Ron Jeffries**\n>\n>   简单代码, 依其重要顺序:\n>\n>   - 能通过所有测试\n>   - 没有重复代码\n>   - 体现系统中的全部设计理念\n>   - 包括尽量少的实体, 比如类、方法、函数等\n>\n>   减少重复代码, 提高表达力, 提早构建简单抽象。\n>\n> - **Wiki 发明者 - Ward Cunningham**\n>\n>   如果每个例程都让你感到深合已意，那就是整洁代码。如果代码让编程语言看起来像是专为解决那个问题而存在，就可以称之为漂亮的代码。\n\n## 怎样去写好质量代码?\n\n> 此篇主要是提出一些相关的思考, 后续将针对以下部分做详细总结。\n\n### 制定统一的编码规范\n\n众所周知, 一个团队中的开发水平很能保持高度统一,  所以这个是我们需要借助一些工具来制定项目的编码规范。目前(2022年)是用较为广泛的为 `eslint` + `prettier` 组合, 针对编码规范, 我觉得应该从这些方面出发\n\n- **统一技术栈**: 项目中切忌出现不同的技术栈风格(如有人使用`less`, 也有人使用`sass`)。\n- **统一代码风格**: 如统一使用`空格2格`还是`tab 4格`需要保持一致, 否则切换页面后会产生不是同一个项目的错觉。\n- **语义化命名**: 较好的命名可以让阅读者有信息继续阅读下去, 这不是夸张说法, 试想看到一个名为 `q`和`queryUserInfo`的函数, 谁更能让你愿意阅读下去呢?\n- **写好注释**: 这对阅读代码具有重要的参考意义。但这里所说的注释应**避免无意义注释**、**魔法注释**。\n\n### 使用一些实现技巧\n\n> 各语言的使用技巧各不相同, 唯有不断积累总结才有效果, 下方以 javascript 为例\n\n- #### 巧用数组\n\n  1. `some`、`every`、`include`\n  2. `find`、`findIndex`、`indexOf`\n  3. `reduce`\n\n- #### 巧用运算符\n\n  1. `+`、`-`、`!`、`~`\n  2. `&`、`&&`、`|`、`||`\n  3. `>>`、`<<`\n\n\n- #### 其他\n\n  1. `Object.assign`、`Object.keys`、`Object.values`、`Object.entries`\n  2. `performance.now`\n  3. `URLSearchParams`\n  4. 展开操作符\n\n### 遵循设计原则\n\n- **单一职责**: 程序功能要单一明确\n- **开闭原则**: 尽量减少原有代码的修改\n- **里式替换原则**: 子类能够覆盖父类\n- **接口隔离原则**: 保持接口的单一独立(JS中较少)\n- **依赖倒置原则**: 不依赖具体实现\n- **KISS原则**: 尽量保持代码简单\n- **YAGNI原则**: 避免过度设计, 但需要考虑扩展性\n- **DRY原则**: 避免重复性代码\n- **LOD原则**: 最小知识原则\n\n### 合理使用设计模式\n\n> 参考链接: https://refactoringguru.cn/design-patterns/catalog \n>\n> TIPS: 需自寻🍇,  另链接文章中出现的政治言论与本人无关, 一切以学习为主\n>\n\n- **工厂方法**: 父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型\n- **抽象工厂**: 创建一系列相关的对象， 而无需指定其具体类\n- **生成器模式**: 该模式允许你使用相同的创建代码生成不同类型和形式的对象。\n- **原型模式**: 能够复制已有对象， 而又无需使代码依赖它们所属的类。\n- **单例模式**: 能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。\n- **适配器模式**: 能使接口不兼容的对象能够相互合作。\n- **桥接模式**: 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。\n- **组合模式**: 可使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。\n- **装饰模式**: 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。\n- **外观模式**: 能为程序库、 框架或其他复杂类提供一个简单的接口。\n- **享元模式**: 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。\n- **代理模式**: 能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。\n- **责任链模式**: 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。\n- **命令模式**: 可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。\n- **迭代器模式**: 能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。\n- **中介模式**: 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。\n- **备忘录模式**: 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。\n- **观察者模式**: 允许定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。\n- **状态模式**: 能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。\n- **策略模式**: 能定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。\n- **模版模式**: 在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。\n- **访问者模式**: 能将算法与其所作用的对象隔离开来。\n\n## 结语\n\n我相信作为程序猿, 追求好的代码质量是我们一生的目标和使命。在我看来, 我们需要需要做到以下几点: \n\n1. **夯实基础。** 一个老生常谈但又不得不坚持做的一件事, 万丈高楼平地起, 再高的楼房也是从打基础开始的。只有掌握好了基础知识, 无论是阅读代码还是自己编写时才能得心应手, 信手拈来。无论新出的框架如何变化, 其底层实现也就那样。\n2. **具有强迫症精神**。要勇于挑战自己,  严格要求自己, 要敢于重构已有代码, 好的代码都是一行一行深思熟虑的结果。\n3. **积极拥抱开源。**一定程度上, 开源项目已经积累了众多优秀大佬的实现思想, 特别是知名项目, 经过不断的重构迭代, 提炼出来的思想都是我们平常接触不到的。\n\n最后用一句勉励自己的话来结束这篇文章: **代码是用来阅读的, 只是顺便实现了功能**\n","tags":["其他"],"categories":["其他"]},{"title":"pnpm在做什么","url":"%2Fblog%2F%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8%2Fpnpm%E5%9C%A8%E5%81%9A%E4%BB%80%E4%B9%88%2F","content":"\n\n## 简介\n\n![](./logo.png)\n\n**pnpm和npm/yarn本质是相同, 都是一个包管理工具**, 但相对npm和yarn而言具有如下特征:\n\n1. 节约磁盘空间并提升安装速度\n2. 创建非扁平化的 node_modules 文件夹\n\n> 这是官方所表达设计pnpm的初衷!\n\n## 依赖管理方式\n\n### 嵌套结构\n\nnpm1/npm2采用的是和package.json文件中依赖与次依赖形成的树形结构而生成的node_modules目录结构, 再通过递归安装所有次级依赖所依赖的模块.\n\n以项目中安装了 A | B 两个模块, A 模块依赖了 C | D 模块为例所生成的目录结构将如下所示:\n\n```\nnode_modules\n├─ A@1.0.0\n|  ├─ node_modules\n|  |  ├─ C@1.0.0\n|  |  ├─ D@1.0.0\n├─ B@1.0.0\n```\n\n对于这种各模块间互不关联的情景下如果不出意外这将是一个不错的解决方案,  但意外还是发生了.\n\n以项目中安装了A | B 两个模块, A | B 同时依赖了 C | D 模块为例所生成的目录结构如下所示:\n\n```\nnode_modules\n├─ A@1.0.0\n|  ├─ node_modules\n|  |  ├─ C@1.0.0\n|  |  ├─ D@1.0.0\n├─ B@1.0.0\n|  ├─ node_modules\n|  |  ├─ C@1.0.0\n|  |  ├─ D@1.0.0\n```\n\n此时我们就可以发现2个问题\n\n1. 相同包重复安装, 将导致项目体积过大, 占用了过多的磁盘空间\n2. 依赖层级较深时引用地址将变得很长, 在window下将出现一些莫名问题.\n\n社区里面也出现了诸如此类的“嘲讽”图片\n\n<img src=\"./npm1*2.png\" width='40%' /><img src=\"./npm1.png\" width='40%' style=\"vertical-align: top\"  />\n\n\n### 扁平结构\n\n在这个阶段(**目前npm和yarn都处于这个阶段**), npm和yarn都将依赖进行了扁平化的管理即将依赖都提出到node_modules目录下, 不再有很深层次的嵌套关系. \n\n以上方 A | B 模块都依赖 C | D 模块为例所生成的目录结构如下所示:\n\n```\nnode_modules\n├─ C@1.0.0\n├─ D@1.0.0\n├─ A@1.0.0\n├─ B@1.0.0\n```\n\n对于扁平化后的目录结构, 根据 node require 的加载机制，会不停往上级的node_modules当中去找，如果找到相同版本的包就不会重新安装，这解决了大量包重复安装的问题，而且依赖层级也不会太深。\n\n同样, 理想很丰满, 现实很骨感, 在我们平时使用中不可能会这么“规矩”.\n\n比如我们在 B 模块中使用的是 D@1.0.1 这个版本而不是 D@1.0.0 这个版版, 新的流程将会是如下所示\n\n```\nnode_modules\n├─ C@1.0.0\n├─ D@1.0.0\n├─ A@1.0.0\n├─ B@1.0.0\n|  ├─ node_modules\n|  |  ├─ D@1.0.1\n```\n\n亦或者\n\n```\nnode_modules\n├─ C@1.0.0\n├─ D@1.0.1\n├─ A@1.0.0\n|  ├─ node_modules\n|  |  ├─ D@1.0.0\n├─ B@1.0.0\n```\n\n但由此却又诞生了“幽灵依赖” 和 “依赖分身”以及~~node_modules的结构不稳定性~~\n\n#### 幽灵依赖\n\n幽灵依赖是指在 package.json 中未定义的依赖，但项目中依然可以正确地被引用到。如例子中的 C | D 依赖\n\n#### 依赖分身\n\n依赖分身是指出现重名但不同版本的依赖安装, 此时的模块只能重复安装到模块所依赖的node_modules下, 若存在多个不同模块依赖与根node_modules不同的版本时将重复安装(此时和npm1/2嵌套时期生成的结构相同)\n\n#### 结构不确定性\n\n由于不同的操作系统对依赖的安装顺序不同, 在安装依赖时不同系统间将诞生不一样的目录结构. 而解决方案就是`lock`文件, 无论是package-lock.json(npm@5.x后出现)还是yarn.lock, 都是为了稳定的结构而诞生的.\n\n### pnpm\n\n\n#### 符号链接\n\n> 符号连接又称为软链接, 类如window系统中的 *快捷方式*, 对符号链接文件进行读写的程序会表现得直接对目标文件进行操作.\n\npnpm 的 node_modules 布局就是使用符号链接来创建依赖项的嵌套结构。在node_modules下存在一个全局的缓存池 .pnpm 文件夹, 在这个文件夹中将存放通过硬链接拷贝过来的真实文件, 通过符号连接访问时访问的其实是.pnpm中存在的目标文件.\n\n还是以 A | B 模块都依赖 C | D 模块为例所生成的目录结构如下所示:\n\n```\nnode_modules\n├─ .pnpm\n|  ├─ D@1.0.0\n|  |  ├─ node_modules\n|  |  |  ├─ D -> <store>/D\n|  ├─ C@1.0.0\n|  |  ├─ node_modules\n|  |  |  ├─ C -> <store>/C\n|  ├─ A@1.0.0\n|  |  ├─ node_modules\n|  |  |  ├─ A -> <store>/A\n|  |  |  ├─ C -> ../../C@1.0.0/node_modules/C\n|  |  |  ├─ D -> ../../D@1.0.0/node_modules/D\n|  ├─ B@1.0.0\n|  |  ├─ node_modules\n|  |  |  ├─ B -> <store>/B\n|  |  |  ├─ C -> ../../C@1.0.0/node_modules/C\n|  |  |  ├─ D -> ../../D@1.0.0/node_modules/D\n├─ A@1.0.0 -> ./.pnpm/A@1.0.0/node_modules/A\n├─ B@1.0.0 -> ./.pnpm/B@1.0.0/node_modules/B\n```\n\n如果在 B 模块中使用的是 D@1.0.1 这个版本而不是 D@1.0.0 这个版版, 新的流程将会是如下所示\n\n```\nnode_modules\n├─ .pnpm\n|  ├─ D@1.0.0\n|  |  ├─ node_modules\n|  |  |  ├─ D -> <store>/D\n|  ├─ D@1.0.1\n|  |  ├─ node_modules\n|  |  |  ├─ D -> <store>/D\n|  ├─ C@1.0.0\n|  |  ├─ node_modules\n|  |  |  ├─ C -> <store>/C\n|  ├─ A@1.0.0\n|  |  ├─ node_modules\n|  |  |  ├─ A -> <store>/A\n|  |  |  ├─ C -> ../../C@1.0.0/node_modules/C\n|  |  |  ├─ D -> ../../D@1.0.0/node_modules/D\n|  ├─ B@1.0.0\n|  |  ├─ node_modules\n|  |  |  ├─ B -> <store>/B\n|  |  |  ├─ C -> ../../C@1.0.0/node_modules/C\n|  |  |  ├─ D -> ../../D@1.0.1/node_modules/D\n├─ A@1.0.0 -> ./.pnpm/A@1.0.0/node_modules/A\n├─ B@1.0.0 -> ./.pnpm/B@1.0.0/node_modules/B\n```\n\n这里借用一下官方的关联关系图\n\n<img src=\"./pnpm.jpeg\" width='80%' />\n\n由上方代码结构和官方关系图可得知如下结果:\n\n1. 相同的依赖只会安装一次, 不同模块间相同的依赖, 通过符号链接进行关联. 解决了重复安装、依赖分身的问题.\n2. 根节点只存在package.json中所注入的依赖, 解决了幽灵依赖的问题.\n3. 是用符号链接的方式即解决了依赖路径过长的问题.\n\n**所以基于链接的优势, pnpm 的安装速度会比npm/yarn快近2倍的优势, 同时也大大节约了磁盘的占用空间**\n\n#### 对比图\n\n针对上方一系列的操作后, 效果如下:\n\n<img src=\"./test.png\" width='80%' />\n\n#### 是否pnpm就是最好的解决方案?\n\n首先任何一个解决方案都是当下最好的一个解决方案, 但并不代表这将是最终方案. pnpm依旧存在以下问题:\n\n1. 符号链接兼容性. 存在符号链接不能适用的一些场景，比如 Electron 应用、部署在 lambda 上的应用无法使用 pnpm\n2. 子依赖被提升到同级的目录结构. 虽然由于 Node.js 的父目录上溯寻址逻辑，可以实现兼容。但对于类似 Egg、Webpack 的插件加载逻辑，在用到相对路径的地方，需要去适配\n3. 不同应用的依赖是硬链接到同一份文件，如果在调试时修改了文件，有可能会无意中影响到其他项目\n\n\n## 包管理器的探索\n\n### Deno\n\nNode.JS作者Ryan在JSConf上曾表示node_modules是他对Node的十大遗憾之一, 并在后续介绍并推荐了自己的新作Deno. \n\n<img src=\"./deno.jpeg\" width='80%' />\n\n在Deno中不需要package.json和node_modules，而是将引入源、包名、版本号、模块名全部塞进了 URL 里，通过URL导入依赖并进行全局统一缓存，不仅节省了磁盘空间，也优化了项目结构。\n\n```\nimport * as asserts from 'https://deno.land/std@0.125.0/testing/asserts.ts';\n```\n\n因此Deno中没有包管理器的概念，对于项目中的依赖管理，Deno提供了这样一种方案。由开发者创建dep.ts，此文件中引用了所有必需的远程依赖关系，并且重新导出了所需的方法和类。本地模块从dep.ts统一导入所需方法和类，避免单独使用URL导入外部依赖可能造成的不一致的问题。\n\n```typescript\n// dep.ts\nimport { \n\tasset, \n\tassetEquals \n} from 'https://deno.land/std@0.125.0/testing/asserts.ts';\n\n// index.ts\nimport { asset } from './deps.ts';\n```\n\n\n### yarn Plug’n’Play(yarn PnP)\n\nyarn 也意识到了在之前版本里存在的问题, 于是在2020年1月发布了v2版本的重大更新, 其中一项重要更新就是 Plug’n’Play（Plug'n'Play = Plug and Play = PnP，即插即用）。\n\n现阶段 yarn install 操作会执行以下 4 个步骤：\n\n1. 将依赖包的版本区间解析为某个具体的版本号\n2. 下载对应版本依赖的 tar 包到本地离线镜像\n3. 将依赖从离线镜像解压到本地缓存\n4. 将依赖从缓存拷贝到当前目录的 node_modules 目录\n\n其中第 4 步同样涉及大量的文件 I/O，导致安装依赖时效率不高（尤其是在 CI 环境，每次都需要安装全部依赖）。\n\n\nPnP 的具体工作原理是: 作为把依赖从缓存拷贝到 node_modules 的替代方案，Yarn 会维护一张名为 .pnp.js 文件的静态映射表，该表中包含了以下信息：\n\n- 当前依赖树中包含了哪些依赖包的哪些版本\n- 这些依赖包是如何互相关联的\n- 这些依赖包在文件系统中的具体位置\n\n.pnp.js 文件中还包含了一个特殊的 resolver，Yarn 会利用这个特殊的 resolver 来处理 require() 请求，该 resolver 会根据 .pnp.js 文件中包含的静态映射表直接确定依赖在文件系统中的具体位置，从而避免了现有实现在处理依赖引用时的 I/O 操作。\n\n\n<!--参考链接: \n\n1. https://juejin.cn/post/7036319707590295565\n2. https://pnpm.io/zh/symlinked-node-modules-structure\n3. https://zhuanlan.zhihu.com/p/165041115\n4. https://www.jianshu.com/p/a805e182798f-->","tags":["pnpm"],"categories":["包管理器"]},{"title":"小程序申请步骤及条件","url":"%2Fblog%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%94%B3%E8%AF%B7%E6%AD%A5%E9%AA%A4%E5%8F%8A%E6%9D%A1%E4%BB%B6%2F","content":"\n### 基本材料\n\n1. 邮箱账号(可以登录接受信息的, 并且没有注册过微信相关的应用)\n2. 小程序Logo\n3. 小程序名称\n\n### 微信公众帐号主体\n\n1. 个人\n\n\t- 身份证姓名\n\t- 身份证号码\n\t- 管理员手机号码\n\n2. 企业\n\n\t- 企业类型\n\t- 企业名称\n\t- 营业执照注册号\n\t- 注册方式\n\t\t- 微信认证, 此方式将支付300元审核费用\n\t\t- 企业对公账号, 此方式需要《开户名称》、《开户银行》、《对公账户》、《开户地点》\n\t- 管理员身份证姓名\n\t- 身份证号码\n\t- 手机号码\n\n### 服务类目\n\n1. 《工具 > 效率》、《工具 > 信息查询》、《商业服务 > 一般财务服务》、《商业服务  >  公关/推广/市场调查》、\n\t\n\t- 不需要其他资料\n\t- 其中除《商业服务 > 一般财务服务》外, 个人主体的小程序都能选择\n\n2. 其他类目\n\n\t- 请[点击此处查看](https://developers.weixin.qq.com/miniprogram/product/material/#%E9%9D%9E%E4%B8%AA%E4%BA%BA%E4%B8%BB%E4%BD%93%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E6%94%BE%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%B1%BB%E7%9B%AE)\n\n> 以上[服务类目1](#服务类目)为我觉得合适的类目, 如果不合适可以再查看其他的类目\n\n### 建议\n\n先用《个人主体》下的[服务类目1](#服务类目)的账号进行提交审核, 如果失败再结合微信审核反馈的信息进行调整","tags":["微信小程序"],"categories":["小程序"]},{"title":"微信小程序发布流程","url":"%2Fblog%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B%2F","content":"\n# 微信小程序发布流程\n<!--\n> 说明: \n> \n> 1. 小程序《密码库》, 以下将简称密码库小程序\n> 2. 图片截图具是来自密码库小程序\n-->\n鉴于密码库小程序开发已经完成, 所以本文将从以下几个方面对小程序发布流程做说明: \n\n 1. 小程序登录\n 2. 小程序如何生成体验版?\n 3. 小程序如何提交审核?\n 4. 小程序如何发布?\n 5. 小程序审核过程中的注意事项.\n\n## 1. 小程序登录\n \n 打开微信公众平台([mp.weixin.qq.com/](httP://mp.weixin.qq.com/)), 使用微信扫码(*拥有密码库小程序管理权限的微信*)或者账号登录(*注册密码库小程序的账号密码*), 进入微信小程序管理后台并点击左侧版本管理菜单\n\n![](./小程序发布流程/sy.png)\n\n## 2. 小程序如何生成体验版?\n\n登录成功后, 点击左侧菜单-版本管理\n\n![](./小程序发布流程/bbgl.png)\n\n 注意到版本管理最后一栏中有个版本号为 0.0.7 的开发版本, 这是开发者通过微信开发工具提交上来的开发版本, 其中可以在此将设置体验版小程序, 操作步骤为: \n \n 1. 点击开发版本栏中向下箭头的按钮, 找到选为体验版的选项\n \n ![](./小程序发布流程/tyb.png)\n\n 2. 修改体验版的默认页面路径, 一般为默认路径不修改\n \n ![](./小程序发布流程/tybsz.png)\n \n 3. 点击提交生成体验版小程序, 此处二维码可扫码打开体验版小程序, 也可继续流程用其他途径打开\n\n ![](./小程序发布流程/tybtj.png)\n \n 4. 设置成功后, 关闭窗口可发现0.0.7版本号下面将提交一个体验版的小标签\n\n ![](./小程序发布流程/tybbq.png)\n \n 5. 点击二维码图标将可以通过扫码进行查看体验版\n\n ![](./小程序发布流程/tybck.png)\n\n## 3. 小程序如何提交审核\n\n登录成功后, 点击左侧菜单-版本管理, 并点击开发版中的提交审核按钮\n\n![](./小程序发布流程/tjsh.png)\n\n勾选复选框, 然后点击确认按钮\n\n![](./小程序发布流程/qrtjsh.png)\n\n点击继续提交\n\n![](./小程序发布流程/jxtj.png)\n\n上一步操作后将新打开一个标签页, 在此页面, 填写当前版本的描述, 其余的内容项在密码库小程序中不涉及, 所以可以不填写, 选择不加急处理(一年一次加急机会, 请在合适的时机再使用), 最后点击提交\n\n![](./小程序发布流程/tjsh2.png)\n\n如看到此页面则证明提交成功\n\n![](./小程序发布流程/tjcg.png)\n\n点击确认按钮, 回到版本管理界面, 可看见审核版本栏将出现我们刚刚申请审核的版本(如若没有发现,请尝试刷新浏览器)\n\n![](./小程序发布流程/kssh.png)\n\n审核结果将在腾讯审核完成后通过微信公众平台公众号通知审核结果\n\n1. 审核通过\n\n![](./小程序发布流程/shtg.png)\n\n2. 审核失败, 失败情况下, 腾讯将会反馈失败的原因, 根据原因进行调整后可进行二次[提交审核的操作](3. 小程序如何提交审核)\n\n## 4. 小程序如何发布\n\n> 小程序发布, 必须在审核通过的状态下才能进行\n\n登录成功后, 点击左侧菜单-版本管理, 点击提交发布\n\n![](./小程序发布流程/tjfb.png)\n\n选择全量发布, 点击提交\n\n![](./小程序发布流程/qlfb.png)\n\n微信扫描二维码, 手机确认发布\n\n![](./小程序发布流程/fbbb.png)\n\n如若出现此界面则说明发布成功\n\n![](./小程序发布流程/fbcg.png)\n\n## 5. 小程序审核过程中的注意事项\n\n鉴于密码库小程序的特殊性, 所以此处有一下几点需要注意\n<!--\n1. 尽量不要修改多次提交审核. 由于私行小程序中包含了金融方面的知识, 所以腾讯在审核的时候很大程度会按照金融主体的企业进行考量审核\n2. 发布的版本描述中尽量不要出现金融相关的字眼, 理由同上-->\n\n1. 使用与小程序内容相关的主体账号\n2. 小程序发布之后, 尽可能的放弃并删除体验版本与开发版本, 且不再继续给其他人进行申请通过, *此条为建议项*","tags":["小程序"],"categories":["小程序"]},{"title":"微信小程序云开发","url":"%2Fblog%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BA%91%E5%BC%80%E5%8F%91%2F","content":"\n<!--云开发转私服\n\n1. 个人账号云开发支付方式\n2. 数据加密\n1. 云开发与私服的不同\n2. 云开发的优势\n3. 云开发有哪些问题和风险\n4. 云开发管理端(web)如何解决\n5. 云开发后期是否能够剥离出来使用自己的服务器\n6. 云开发是否存在安全问题\n7. [什么是Node中间件](https://zhuanlan.zhihu.com/p/106853407)\n8. [Node中间件是什么意思](https://m.html.cn/qa/node-js/12090.html)\n8. [Node中间件模式是什么](https://juejin.cn/post/6844903619209199624)\n9. [中间件和插件有什么区别](https://cnodejs.org/topic/53f2b7af8f44dfa35140bca1)-->\n\n## 微信小程序云开发是什么\n\n> 小程序·云开发是微信团队联合腾讯云推出的专业的小程序开发服务。\n>\n> 开发者可以使用云开发快速开发小程序、小游戏、公众号网页等，并且原生打通微信开放能力。\n>\n> 开发者无需搭建服务器，可免鉴权直接使用平台提供的 API 进行业务开发。\n\n以上为微信小程序官方给出的云开发解释, 简单的说云开发使用的是腾讯的服务器存储后端数据，传统的是自备服务器.\n\n## 云开发的优缺点\n\n开局先上对比图\n\n![](./云开发/tradition.jpeg)\n![](./云开发/cloud.jpeg)\n\n### 优势说明\n\n由上图可以看出\n\n*传统开发模式*\n\n- **开发效率低**：过多的非业务逻辑需要处理，导致开发效率难以提升\n- **资源投入高**：无论是物理机托管，还是云主机维护，都需要较多的人力物力投入\n- **产品上线慢**：前后端联调、资源存储、部署等操作繁杂，上线流程耗时长\n- **日常运维难**：需时刻关注环境运行状况，管理相关资源，运维难度大\n\n*云开发模式*\n\n- **高效开发**：只需编写核心逻辑代码，内建小程序用户鉴权，无需关注后端配置与部署，专注于业务开发\n- **节约成本**：按请求数和资源的运行收费，极大节约时间和成本，提供一定量免费额度使用\n- **官方生态**：原生集成微信SDK，云相关API开箱即用；同时，通过云调用，可免鉴权直接调用微信开放接口\n- **稳定可靠**：底层资源由腾讯云提供专业支持，满足不同业务场景和需求，具备快速拓展能力，确保服务稳定，数据安全\n\n### 劣势说明\n\n1. **云函数运算时间不得超过3秒**。超过3秒未处理完成，直接返回错误\n2. **云函数单次返回数据不得超过1M**。超过1M直接报错\n3. **云函数读取数据库较慢**。云函数 云数据库感觉应该在同一物理环境下，但其实并不是，应该处于不同的云端，因为读取100次数据就已经超过3秒了\n4. **云函数并发次数有限**。这个文档里面配额写得很清楚，免费版并发数只有20次，这里的并发估计是每秒钟调用次数，因为确实很慢很慢, 据实践，每隔半秒调用一个云函数, 调用100遍，还是报告调用次数超限\n5. **云函数不适合做数据库的较大数量查询功能**, 只适合进行10条左右的敏感数据读取，如用户信息等。\n6. **云函数读取云数据库单次最多读取100条**。超过100条需要使用 skip() ,分多次将数据组合起来。\n7. **小程序前端读取云数据库单次最多读取20条**。\n8. **对外开放限制多**。由于小程序云开发自带的云数据库在小程序内部，外部要是想访问这个数据库则需要一个稍微复杂的流程：先使用官方接口获取到调用凭证，在通过这个凭证使用指定的接口来对数据库进行增删改查。此外这个流程中消耗的资源也是算在基础配置里的，每日请求上线5万次\n9. **后期移植不方便, 无法支持通用框架**。如果企业完全使用云开发开发小程序，然后由于某种原因不能使用这种方式了，想独立部署后端的话，将要面临如何移植的问题。云开发太依赖微信平台了。\n\n## 云开发后期是否能够剥离出来使用自己的服务器\n\n1. 通过云函数转私有服务器调用接口\n2. 修改小程序直接调用私有服务器接口, 其中登录状态还是又云函数提供\n\n## 云开发计费模式\n\n云开发计费方式目前分为三种: \n\n- *预付费：个人账户扣款*：适用于个人账户结算的小程序，目前仅支持微信支付\n- *预付费：腾讯云账户扣款*：适用于通过腾讯云账户统一结算的小程序\n- *按量付费：腾讯云账户扣款*：适用于暂时无法准确预估使用量的小程序，目前仅支持从腾讯云账户扣款\n\n> 系统默认使用的支付方式为按量付费：腾讯云账户扣款\n> \n> 点击查看具体[云开发计费相关](https://developers.weixin.qq.com/minigame/dev/wxcloud/billing/quota.html)\n\n云开发计费方式需要注意的有: \n\n1. 切换至按量计费后无法再切换支付方式\n2. 从账户余额被扣为负值时刻起，小程序·云开发资源在 12 小时内可继续使用且继续扣费，12 小时后未及时充值，系统将自动隔离资源且停止扣费。 7*24 小时后，若账户余额未充值到大于 0，按量计费环境将被回收。届时环境中的数据将被清除且不可恢复\n\n\n## 总结\n\n根据目前情况来看, 小程序云开发是一个比较合适应用的一种开发模式, 在本应用中需要做以下几种处理: \n\n1. 开通云开发静态资源管理\n2. 开通云开发内容管理平台, 对应切换至按量付费方式\n\n","tags":["小程序"],"categories":["小程序"]},{"title":"als-block-wxmp 插件使用说明","url":"%2Fblog%2Fals-block%2Fals-block-wxmp%2F","content":"\n\n## 页面拦截\n\n由于系统存在部分需要登录和输入锁屏密码的界面, 所以该拦截存在以下配置项:\n\n|属性|默认值|说明|\n|----|----|----|\n|auth| true | 是否需要授权 |\n|authRouterType| redirectTo | 跳转到授权页面的方式 |\n|authPage| '' | 授权页面路径 |\n|login| true | 是否需要登录 |\n|loginRouterType| redirectTo | 跳转到登录页面的方式 |\n|loginPage| '' | 登录页面路径 |\n\n```javascript\n// 注册拦截器\nconst { Interceptor } = require('./al-wxmp.min.js');\nnew Interceptor({\n  auth: true,\n  authRouterType: 'redirectTo',\n  authPage: '/pages/login/auth/auth',\n  login: true,\n  loginRouterType: 'reLaunch',\n  loginPage: '/pages/login/auth/auth'\n})\n\n\n// 使用拦截器\nPage({\n  interceptor: {\n    auth: true,\n    login: false\n  }\n})\n```\n\n## 路由函数\n\n由于小程序中带有参数的页面跳转略微复杂, 所以对页面跳转进行一层包裹\n\n```javascript\nconst { Router } = require('./al-wxmp.min.js');\n\n// 保留当前页面，跳转到应用内的某个页面\nRouter.navigateTo(\n  '/pages/index/index', \n  { id: 1234567890 },\n  { auth: false }\n)\n// 关闭所有页面，打开到应用内的某个页面\nRouter.reLaunch(\n  '/pages/index/index', \n  { id: 1234567890 },\n  { auth: false }\n)\n// 关闭当前页面，跳转到应用内的某个页面\nRouter.redirectTo(\n  '/pages/index/index', \n  { id: 1234567890 },\n  { auth: false }\n)\n```\n> Tips: 路由组件传递参数格式一致, 均为(路径[String], 参数[String|Object], [拦截器参数](#页面拦截)(不传则使用注册拦截器时的参数配置))\n\n\n## 请求组件\n\n由于请求能够做到更多的复用, 所以将此进行封装\n\n### 实例化配置项\n|属性|默认值|说明|\n|----|----|----|\n|baseUrl|  | 默认请求地址(后端网关地址) |\n|hideErrMsg| false | 是否隐藏错误信息 |\n|needReject| false | 是否需要 Promise 的 catch 分之 |\n|isSuccess| (data) => data.code === 0 | 是否成功的判断 |\n|showErrMsgFn| (error) => error.msg || \"\" | 返回错误信息的函数 |\n\n### 请求配置项\n|属性|默认值|说明|\n|----|----|----|\n|baseUrl|  | 默认请求地址(后端网关地址) |\n|hideErrMsg| false | 是否隐藏错误信息 |\n|needReject| false | 是否需要 Promise 的 catch 分之 |\n|headers|  | 需要携带的headers |\n\n```javascript\n// 注册请求\nconst { Request } = require('./al-wxmp.min.js');\nnew Request({\n  baseUrl: 'http://120.27.27.108:3000/',\n  hideErrMsg: false,\n  needReject: false,\n  isSuccess: (data) => data.code === 0,\n  showErrMsgFn: (error) => error.msg || \"\",\n});\n\n\n// GET 使用, 隐藏提示、返回catch分支\nRequest.get(\n  '/user/get', \n  { id: '123' }, \n  { hideErrMsg: true, needReject: true }\n).then(console.log).catch(console.error)\n// POST 使用, 设置headers\nRequest.post(\n  '/user/save', \n  { name: 'Alisdon' }, \n  { headers: { 'Content-Type': 'application/json' } }\n).then(console.log)\n// 使用其他 baseUrl\nRequest.post(\n  '/user/login', \n  { userName: 'Alisdon' }, \n  { baseUrl: 'http://www.baidu.com' }\n).then(console.log)\n```\n> 无论是GET还是POST最多能接受3个参数, 依次为*请求地址*, *请求参数*, *请求配置项*\n\n\n## 消息组件\n\n由于消息存在大量的复用, 所以将此进行封装\n\n```javascript\nconst { Message } = require('./al-wxmp.min.js');\n// 注册消息组件\nwx.$message = Router;\n\n\n// 成功提示\nwx.$message.success('成功提示');\n// 成功提示\nwx.$message.error('错误提示');\n// 弹框提示\nwx.$message.modal('敏感操作, 是否继续?').then(() => {\n  wx.$message.success('操作成功')\n});\n```\n> 此处的成功和失败没有区分, 所以将表现一致, 但希望依旧按照业务使用, 方便后期修改\n\n## 缓存组件\n\n本插件提供了便利的缓存功能, 其中内置了用户信息(userinfo)的处理\n\n```javascript\nconst { Storage } = require('./al-wxmp.min.js');\n// 注册缓存\nwx.$storage = Storage;\n\n\n// 用户信息的获取\nconst userInfo = wx.$storage.userinfo;\n// 用户信息的设置, 支持增量修改\nwx.$storage.userinfo = { name: 'alisdon' }\n// 清除用户信息\nwx.$storage.userinfo = 'clean';\n```\n\n缓存组件还支持自定义扩展\n\n|方法名|参数|说明|\n|----|----|----|\n|extend| (key, storageKey, type) => void | key 为自定义扩展的关键属性, storageKey 为数据缓存的key, type 为需要缓存数据的类型, 支持 'string' 和 'object', 其中鉴于系统内置方法, **key 不能使用 'userinfo' 和 'extend', storageKey 不能是用 'A_UI'** |\n\n```javascript\nconst { Storage } = require('./al-wxmp.min.js');\n// 自定义扩展\nStorage.extend('token', 'A_TICKET', 'string');\n// 注册缓存\nwx.$storage = Storage;\n\n\n// 获取自定义的内容\nconst token = wx.$storage.token;\n// 增量修改自定义内容\nwx.$storage.token = '1234567890'\n// 清除自定义信息\nwx.$storage.token = 'clean';\n```\n\n","tags":["als-block"],"categories":["als-block"]},{"title":"als-block-crud 使用说明","url":"%2Fblog%2Fals-block%2Fals-block-crud%2F","content":"\n## 介绍\n\n[Als-Block-Crud](http://47.103.55.103:3000/wanglf/al-block-crud)是一套基于[Vue.js](https://cn.vuejs.org/)和[Element UI](http://element-cn.eleme.io/#/zh-CN)的表格组件。`als-block-crud` 将 `Element` 的功能进行了封装。大部分功能可由配置 `json` 实现，在实现并扩展了 `Element` 表格组件功能的同时，降低了开发难度，减少了代码量，大大简化了开发流程。\n\n## 文档\n\n- [als-block-table 表格](./table/)\n- [als-block-form 表单](./form/)\n- [als-block-menu 菜单](./menu/)\n- [als-block-dialog 模态框](./dialog/)\n\n## 功能\n\n- 继承了 Element 中表格所有功能\n- 继承了 Element 中表单所有功能\n- 使用 Element 中的组件渲染表格内容和表单内容\n- 表单校验\n- 表格内编辑\n- 渲染自定义组件\n- 菜单\n- 模态框\n\n## 安装\n\n### CDN\n\n```javascript\n<script src='./als-block-crud.min.js'></script>\n```\n\n> 由于服务器过期, 可在底部联系作者\n\n### npm（暂未放入 npm）\n\n```javascript\nnpm i element-ui als-block-crud -S\n```\n\n## 在项目中使用\n\n在使用的时候需要对组件进行配置，以下为所有默认配置，使用时可自定义完善配置。\n_项目配置以`axios`请求得到参数格式来进行案例说明：_\n\n```javascript\n不分页返回的格式\n{\n  ...axios.response,\n  status: 200,\n  statusText: 'OK',\n  data: {\n    {\n      code: 200,\n      data: [],\n      msg: ''\n    }\n  }\n}\n\n分页返回的格式\n{\n  ...axios.response,\n  status: 200,\n  statusText: 'OK',\n  data: {\n    {\n      code: 200,\n      data: {\n        list: [],\n        pageSize: 10,\n        pageIndex: 1,\n        total: 10\n      }\n      msg: ''\n    }\n  }\n}\n```\n\n在`main.js`中写入以下内容：\n\n```javascript\nimport Vue from \"vue\";\nimport ElementUI from \"element-ui\";\nimport \"element-ui/lib/theme-chalk/index.css\";\n\nVue.use(ElementUI);\nVue.use(window.AlsBlockCrud, {\n  table: {\n    // 分页相关配置\n    pagination: {\n      // 布局\n      layout: \"sizes, prev, pager, next, total, ->\",\n      // 下拉框的选项\n      sizes_value: [10, 20, 50, 100],\n      // 每页显示条数的key\n      size: \"pageSize\",\n      // 每页显示条数的默认值\n      size_default_value: 10,\n      // 当前页的key\n      index: \"pageIndex\",\n      // 当前页的默认值\n      index_default_value: 1,\n      // 总条数的key\n      total: \"total\",\n    },\n    // 分页时数据源路径\n    path_data: \"data.data.list\",\n    // 不分页时的数据源路径\n    path_data_no_pagination: \"data.data\",\n    // 每页显示条数的路径\n    path_size: \"data.data.pageSize\",\n    // 当前页的路径\n    path_index: \"data.data.pageIndex\",\n    // 总条数的路径\n    path_total: \"data.data.total\",\n    // 列表默认高度，可在使用中覆盖，可设置['auto', '100%', Number + 'px']\n    height: \"auto\",\n    // 是否默认开启边框，可在使用中覆盖\n    border: true,\n    // 是否默认开启斑马条纹，可在使用中覆盖\n    stripe: true,\n    // 默认表头样式，可在使用中覆盖\n    header_cell_style: {},\n    // 展示加载中\n    show_loading: true,\n    // 字典映射\n    dict_props: {\n    \t// 映射的 value\n      value: \"value\",\n      // 映射的 名称\n      label: \"label\",\n      // 如果没有对应值需要显示的内容\n      emptyValue: \"\",\n    },\n    // 请求失败的回调\n    on_request_error: function(error) {\n      // 获取服务端返回的 data 值\n      const serverResult = error.data || {};\n      // 提示信息\n      this.$message.error(serverResult.msg || \"系统错误\");\n    },\n  },\n  form: {\n    // 表单验证触发方式\n    trigger: [\"blur\", \"change\"],\n    // 是否需要验证特殊字符\n    need_valid_special_chart: true,\n    // 手机号正则\n    valid_regexp_phone: /1[3-9][0-9]{9}$/,\n    // 邮箱正则\n    valid_regexp_email: /^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/,\n    // ip正则\n    valid_regexp_ip: /^(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])(\\.(\\d{1,2}|1\\d\\d|2[0-4]\\d|25[0-5])){3}$/,\n    // 编码正则\n    valid_regexp_code: /^[a-zA-Z0-9]+$/,\n    // 特殊字符正则\n    valid_regexp_special_chart: /[`~!@#$%^&*()_\\-+=<>?:\"{}|,.\\/;'\\\\[\\]·~！@#￥%……&*（）——\\-+={}|《》？：“”【】、；‘’，。、 ]/gim,\n    // 默认属性\n    default_options: {\n      // 行占比\n      span: 24,\n      // 行间距\n      gutter: 0,\n      // 输入框默认属性\n      input: {},\n      // 下拉框默认属性\n      select: {},\n    },\n  },\n});\n\nnew Vue({\n  el: \"#app\",\n  render: (h) => h(App),\n});\n```\n\n至此，你就可以愉快的使用`Als-Block-Crud`组件了\n\n\n## 联系我\n![](./Wechat.jpeg)\n","tags":["als-block"],"categories":["als-block"]},{"title":"als-block-dialog 使用说明","url":"%2Fblog%2Fals-block%2Fals-block-crud%2Fdialog%2F","content":"\n## 模态框\n\n`Als-Block-Crud`对模态框进行了二次封装，意为开发带来更多的便利，减少开发时多余代码的`Ctrl+c`、`Ctrl+v`。\n\n### 功能说明\n\n- [x] 关闭即摧毁\n- [x] 多配置底部区域\n\n### props 对象\n\n```\ndialogMap: {\n  options: {\n    title: '模态框'，\n    showClose: true\n  },\n  footer: {\n    onSubmitClick: this.dialogSave\n  }\n}\n```\n\n### 配置说明\n\n| 属性名  | 说明         | 默认值 |\n| ------- | :----------- | :----- |\n| options | 其他绑定属性 |        |\n| footer  | 窗体底部配置 |        |\n\n> `options`为`element-ui`的组件配置\n\n### 底部说明 - footer 配置\n\n| 属性名           | 说明             | 默认值                  |\n| ---------------- | :--------------- | :---------------------- |\n| showCancelButton | 是否显示取消按钮 | true                    |\n| cancelButtonText | 取消按钮文本     | 取 消                   |\n| showSubmitButton | 是否显示确定按钮 | true                    |\n| submitButtonText | 确定按钮文本     | 确 定                   |\n| onCancelClick    | 点击取消按钮事件 | 只想\\$emit('close')事件 |\n| onSubmitClick    | 点击确定按钮事件 |                         |\n\n### 事件\n\n| 事件名 | 说明           | 返回值 |\n| ------ | :------------- | :----- |\n| close  | 关闭模态框事件 | 无     |\n\n### 方法\n\n| 方法名 | 说明       | 返回值 |\n| ------ | :--------- | :----- |\n| open   | 打开模态框 | 无     |\n| close  | 关闭模态框 | 无     |\n\n> 底部按钮可通过`slot`为`footer`的插槽进行扩展\n\n### 案例\n\n```bash\n<template>\n  <el-button type=\"primary\" @click=\"handleOpenDialog\">打开模态框</el-button>\n  <als-block-dialog ref=\"AlBlockDialog\" :dialog-map=\"dialogMap\" />\n</template>\n\n<script>\nexport default {\n  name: 'AlBlockMenu',\n\n  data () {\n    return {\n      dialogMap: {\n        options: {\n          title: '模态框'\n        }\n      }\n    }\n  },\n\n  methods: {\n    handleOpenDialog () {\n      this.$refs.AlBlockDialog.open()\n    }\n  }\n}\n</script>\n```\n","tags":["als-block"],"categories":["als-block"]},{"title":"als-block-menu 使用说明","url":"%2Fblog%2Fals-block%2Fals-block-crud%2Fmenu%2F","content":"\n## 菜单篇\n\n`Als-Block-Crud`对菜单进行了二次封装，意为开发带来更多的便利，减少开发时多余代码的`Ctrl+c`、`Ctrl+v`。\n\n### 功能说明\n\n- [x] 自动识别子级\n\n### props 对象\n\n```\nmenuMap: {\n  options: {},\n  lisenters: {},\n  menuData: []\n}\nprops: {\n  path: 'path',\n  name: 'name',\n  icon: 'icon',\n  children: 'children'\n}\n```\n\n> 1. `options`为`element-ui`中`el-menu`的属性，可传入`Object`也可以传入返回`Object`的`Function`.\n> 2. `lisenters`为`element-ui`中`el-menu`的事件，可传入`Object`也可以传入返回`Object`的`Function`.\n> 3. `props` 为字端映射，可在返回的数据与默认字端不一致时使用\n\n### 菜单数据\n\n| 属性名   | 说明     | 默认值（接收值） |\n| -------- | :------- | :--------------- |\n| path     | 路由地址 |                  |\n| name     | 菜单名称 |                  |\n| icon     | 菜单图标 |                  |\n| children | 子级菜单 |                  |\n\n### 案例\n\n```\n<template>\n  <als-block-menu ref='mainMenu' :menu-map='menuMap'></als-block-menu>\n</template>\n\n<script>\nexport default {\n  name: 'AlsBlockMenu',\n\n  data () {\n    return {\n      menuMap: {\n        options: {\n          defaultActive: '/index'\n        },\n        listeners: {\n          select: path => this.$router.push(path)\n        },\n        menuData: [{\n          path: '/index',\n          title: '首页',\n          icon: 'el-icon el-icon-s-grid',\n          children: [{\n            path: '/subIndex',\n            title: '二级菜单',\n            icon: 'el-icon el-icon-message-solid',\n          }]\n        },\n        {\n          path: '/user',\n          title: '用户管理',\n          icon: 'el-icon el-icon-eleme'\n        }]\n      }\n    }\n  }\n}\n</script>\n```\n","tags":["als-block"],"categories":["als-block"]},{"title":"als-block-table 使用说明","url":"%2Fblog%2Fals-block%2Fals-block-crud%2Ftable%2F","content":"\n## 列表篇\n\n`Als-Block-Crud`对列表进行了二次封装，意为开发带来更多的便利，减少开发时多余代码的`Ctrl+c`、`Ctrl+v`。\n\n### 功能说明\n\n- [x] 本地数据或远程数据展示\n- [x] 初始选中状态设置\n- [x] 集成分页组件\n- [x] 自定义列表项\n- [x] 兼容`element-ui`所有属性\n- [ ] 本地数据分页\n\n### props 对象\n\n```javascript\nselectedKeys: ['1']\n\ntableMap: {\n  options: {},\n  columns: [],\n  dataSource: [],\n  listeners: {}\n}\n\npagination: {\n  pageSizes: [10, 20, 50, 100],\n  pageSize: 10,\n  pageIndex: 1,\n  total: 0,\n  layout: 'sizes, prev, pager, next, total, ->'\n}\n\n```\n\n> 1. `pagination`为所见参数配置，默认开启，设置 boolean 类型的 false 则关闭，开启时需在引用组件时进行配置使用，如获取`pageSize`的路径\n> 2. `pageSize`和`pageIndex`为本次案例使用的分页信息，实际使用中请配置成项目字段\n> 3. `tableMap.dataSource`为列表数据源，优先使用\n> 4. `tableMap.listeners`为列表事件监听集合，可自由添加配置\n> 5. `selectedKeys`为选中行的 key 值，需要在`table/options`下设置行关键值`currentRowKey`，`currentRowKey`默认为`id`\n\n### options 对象\n\n| 属性名           | 说明                                                                                                                                              | 类型             | 函数参数     | 默认值                                  |\n| ---------------- | :------------------------------------------------------------------------------------------------------------------------------------------------ | :--------------- | :----------- | :-------------------------------------- |\n| immediately      | 是否在页面加载完成立即请求列表数据                                                                                                                | Boolean/Function | 无           | true                                    |\n| requestApi       | 请求列表数据函数，需返回 Promise 对象                                                                                                             | Function         | 无           |                                         |\n| requestParams    | 除去分页信息外的参数对象，可直接传入 JSON 对象或提供返回值为 JSON 对象的函数                                                                      | Object/Function  | 无           |                                         |\n| deleteApi        | 删除数据地址，需返回 Promise 对象，参数来自调用[删除方法](#方法)时传入的值                                                                        | Function         | 无           |\n| firstCellType    | 第一列类型。有效值`selection`、`index`、`expand`、`none`， 为 expand 时在组件中嵌入名称为`expand`的作用域插槽（与其他行取值一致）, `none`为不显示 | String/Function  | 无           | selection                               |\n| headerCellStyle  | 表头样式，可在引用组件时进行配置使用                                                                                                              | Object           | 不可使用函数 | 无                                      |\n| onRequestSuccess | 请求成功的回调                                                                                                                                    | Function         | xhrResponse  |                                         |\n| onRequestError   | 请求失败的回调                                                                                                                                    | Function         | error        | 依赖全局配置中 `table.on_request_error` |\n| ...              | elementUI 表格的其他属性，可自由配置                                                                                                              | 不可使用函数     |              |\n\n> - `height`、`stripe`、`border`已在引用组件时进行配置使用\n> - `ref` 由于 ref 值非响应数据，故封装的时候将`el-table`的`ref`确定为`alBlockTable`\n\n### columns 数组对象\n\n| 属性名   | 说明                                                                                                                            | 类型             | 函数参数                   | 默认值                                                                                                                                                                                                              |\n| -------- | :------------------------------------------------------------------------------------------------------------------------------ | :--------------- | :------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| field    | 映射标识                                                                                                                        | String/Function  | 无                         |                                                                                                                                                                                                                     |\n| label    | 显示名称                                                                                                                        | String/Function  | 无                         |                                                                                                                                                                                                                     |\n| show     | 是否显示                                                                                                                        | Boolean/Function | 无                         | true                                                                                                                                                                                                                |\n| slot     | 插槽名                                                                                                                          | String/Function  | 无                         |                                                                                                                                                                                                                     |\n| dicts    | 字典数据, 数组内容由注册时决定                                                                                                                      | Array/Function   | 无                         |  如传入[{ value: '1', label: '文本', type: 'primary' }] , value 和 label 由注册时映射. type 为 elTag 的type, 不传则直接显示文本                                                                                                                                                                                                            |\n| render   | 列渲染函数。可编写[render 函数](https://cn.vuejs.org/v2/guide/render-function.html#%E5%9F%BA%E7%A1%80)，或安装 jsx 插件进行开发 | Function         | (当前行相关信息, 渲染函数) |                                                                                                                                                                                                                     |\n| handle   | 操作项数组，见下方[操作项说明](#操作项handle说明)                                                                               | Array            | 无                         |                                                                                                                                                                                                                     |\n| options  | elementUI 表格的其他属性，可自由配置                                                                                            | Object           | 不可使用函数               | {<br/>immediately: true, <br/>currentRowKey: 'id', <br/>firstCellType: 'selection', <br/>headerCellStyle: 取决于全局配置, <br/>height: 取决于全局配置,<br/>stripe: 取决于全局配置,<br/>border: 取决于全局配置<br/>} |\n| listener | elementUI 表格的事件，可自由配置                                                                                                | Object           | 无                         |                                                                                                                                                                                                                     |\n\n### 方法\n\n| 方法名             | 功能                                                                          | 接受参数类型                           | 用途                             |\n| ------------------ | :---------------------------------------------------------------------------- | :------------------------------------- | :------------------------------- |\n| loadTableData      | 重载列表数据，需提供 requestApi，返回 Promise 对象可使用                      | 无                                     | 表单编辑、列表删除后刷新页面     |\n| searchTableData    | 根据传入的对象查询列表数据，需提供 requestApi，返回 Promise 对象可使用        | Object                                 | 搜索                             |\n| batchDelTableData  | 批量删除数据，自动检测是否勾选数据，需提供 deleteApi，返回 Promise 对象可使用 | 任意，默认为{ids: 以,分割勾选的 id 值} | 批量删除                         |\n| delTableData       | 删除数据，需提供 deleteApi，返回 Promise 对象可使用                           | 任意，默认为{id: id}                   | 删除单条数据                     |\n| toggleRowSelection | 切换行选中状态，根据传入的行 key 进行勾选显示，需提供 currentRowKey,默认为 id | Array<br/>String<br/>Function          | 单选列表或多选列表选中或取消选中 |\n\n### 操作项 handle 说明\n\n```javascript\nhandle: [{\n  html: '<i class=\"el-icon-edit\"></i>编辑',// 当前按钮的html\n  show: rows => rows.row.age > 18,        // 是否显示\n  disabled: rows => rows.row.age > 18,    // 是否不可用\n  type: 'button',                         // 按钮类型\n  style: '',                              // 按钮样式\n  click: rows => console.log(rows)        // 按钮点击事件\n}]\n```\n\n> 以上参数可直接返回字符串，也可以执行传入当前行数据的函数\n\n### 案例\n\n```javascript\n<template>\n  <als-block-table ref='mainTable' :table-map='tableMap'></als-block-table>\n</template>\n\n<script>\nexport default {\n  name: 'AlsBlockTable',\n\n  data () {\n    return {\n      tableMap: {\n        options: {\n          requestApi: (params) => axios.get('get', params),\n          requestParams: { orgId: '1' },\n          deleteApi: (params) => axios.delete('del', params),\n        },\n        columns: [\n          { field: 'name', label: '姓名' },\n          { field: 'age', label: '年龄',\n            render: ({ row }, h) {\n              return row.age > 18 ? h('span', {}, '成人') : h('span', {}, '未成年')\n            }\n          },\n          { field: 'sex', label: '性别',\n            dicts: [\n              { label: '男', value: 1, type: 'default' },\n              { label: '女', value: 0, type: 'warning' },\n            ]\n          },\n          { field: '', label: '操作',\n            options: { width: '120px' },\n            handle: [{\n              html: '<i class=\"el-icon-edit\"></i>编辑',\n              type: 'primary',\n              click: rows => {\n                console.log(rows)\n              }\n            },\n            {\n              html: '<i class=\"el-icon-delete\"></i>删除',\n              type: rows => rows.row.age > 22 ? 'primary' : 'danger',\n              click: ({row}) => {\n                console.log(row);\n                this.$refs.mainTable.delTableData({id: row.id})\n              }\n            }]\n          }\n        ]\n      }\n    }\n  }\n}\n</script>\n```\n","tags":["als-block"],"categories":["als-block"]},{"title":"als-block-form 使用说明","url":"%2Fblog%2Fals-block%2Fals-block-crud%2Fform%2F","content":"\n## 表单篇\n\n`Als-Block-Crud`对表单进行了二次封装，意为开发带来更多的便利，减少开发时多余代码的`Ctrl+c`、`Ctrl+v`。\n\n### 功能说明\n\n- [x] 简化表单校验开发代码\n- [x] 分离提交参数\n- [x] 自定义表单项\n- [x] 表单项描述\n- [x] 兼容`element-ui`所有属性\n- [x] 控制单项宽度\n\n### props 对象\n\n```javascript\nformMap: {\n  options: {},\n  formData: {},\n  formComponents: []\n}\n```\n\n> `formData`为最后提交的参数，不做描述\n\n### options 对象\n\n| 属性名        | 说明                                                                    | 默认值 |\n| ------------- | :---------------------------------------------------------------------- | :----- |\n| column        | 显示配置，[详情点击此处](#列显示配置)，也可直接传`Number`设置`span`的值 |        |\n| submitApi     | 请求地址，需返回`Promise`对象                                           |        |\n| submitBefore  | 保存前函数，需返回带传递参数的`Promise`对象                             |        |\n| labelWidth    | `label`的宽度                                                           | 80px   |\n| labelPosition | `label`的位置                                                           | right  |\n| ...           | `element-ui`表单的其他属性，可自由配置                                  |        |\n\n### 列显示配置\n\n| 属性名 | 说明                                                   | 默认值 |\n| ------ | :----------------------------------------------------- | :----- |\n| gutter | 每列展示间隔，可在引入时配置默认值                     | 0      |\n| span   | 每列展示所占用的比列，共 24 等分，可在引入时配置默认值 | 24     |\n| ...    | `element-ui`组件`col`的其他属性，可自由配置            |        |\n\n### formComponents 数组\n\n| 属性名      | 说明                                                                                                       | 类型                                                   | 函数参数   | 默认值 |\n| ----------- | :--------------------------------------------------------------------------------------------------------- | :----------------------------------------------------- | :--------- | :----- |\n| label       | 显示文本                                                                                                   | String/Function                                        | (formData) |        |\n| component   | 元素类型，有效值:`input`,`number`,`textarea`,`select`,`checkbox`,`radio`,`switch`,`date`,`button`,`render` | String                                                 |            |        |\n| name        | 对应 formData 中的 key                                                                                     | String/Function                                        | (formData) |\n| show        | 是否显示                                                                                                   | Boolean/Function                                       | (formData) | true   |\n| column      | 列配置，`element-ui`中`col`的配置项                                                                        | Object/Function                                        | (formData) |        |\n| disabled    | 是否不可用                                                                                                 | Boolean/Function                                       | (formData) | false  |\n| rules       | 校验规则，[详情点击此处](#表单校验rules说明)                                                               | Object/Array/Function                                  | (formData) |        |\n| listeners   | 事件处理集合                                                                                               | Object                                                 |            |        |\n| options     | elementUI 表单元素其他绑定属性                                                                             |                                                        |            |        |\n| dataSource  | 数据源，用于 radio，checkbox，select，render 组件的数据配置                                                | 根据元素类型确定，详情见[下方 dataSource](#案例)的运用 |            |        |\n| description | 描述                                                                                                       | String/Function                                        | (formData) |        |\n\n### 方法\n\n| 事件名 | 说明                                  | 返回值                        |\n| ------ | :------------------------------------ | :---------------------------- |\n| submit | 提交的方法，需要和`submitApi`配合使用 | 提交请求后的`Promise`对象     |\n| valid  | 表单校验                              | `Boolean`类型的`true`/`false` |\n| reset  | 重置表单                              | 无                            |\n\n### 表单校验 rules 说明\n\n```javascript\nrules: {\n  required: true,          // 开启必填校验\n  required: {\n    message: '请输入xxx'    // 错误时提示的消息，见下方说明\n  },\n  required: [{\n    required: true,\n    message: '请输入xxx',\n    trigger: ['change', 'blur']\n  }],\n  phone: true,          // 开启手机号校验\n  phone: {},\n  email: true,          // 开启邮箱校验\n  email: {},\n  number: true,         // 开启数字校验\n  number: {},\n  code: true,           // 开启数字和字母校验\n  code: {},\n  port: true,           // 开启端口校验\n  port: {},\n  ip: true,             // 开启ip校验\n  ip: {\n    contain: 'localhost'   // 可传入数组或以,分割的字符串\n  },\n  integer: true,        // 开启整数校验\n  integer: {\n    positive: true,   // 正整数，与负整数二选一\n    negative: true,   // 负整数，与正整数二选一\n    containZero: true,// 是否包含0， 在正负整数设置时有效\n    min: 1,           // 最小值\n    max: () => 10,    // 最大值\n  },\n  length: {\n    min: 1,           // 最小值\n    max: () => 10,    // 最大值\n    len: 5            // 特定长度\n  },\n  regular: {\n    pattern: /./\n  },\n  specialChar: {\n    message: char => `存在非法字符${char}`,   // 自定义提示可接受过滤后所包含的的特殊字符\n    filter: 'all'                           // 过滤所有特殊字符\n    filter: '@s.'                           // 过滤@.两个特殊字符（以s分割的字符串）\n    filter: [\"@\", \".\"]                      // 过滤@.两个特殊字符\n  }\n}\n```\n\n> 1. 可传返回对应类型的函数或对应类型数据，如`length`中最大值和最小值的用法等效。\n> 2. 若只需开启某规则不定义其他属性，可直接设置 true 属性，反之亦然。_可设置 Boolean 类型的已全部罗列[上方说明](#表单校验rules说明)_，如`required`。\n> 3. 若当前规则需要添加其他属性，可使用 Object 对象进行配置，_规则为 Object 对象时也为开启状态_。如`required`。\n> 4. `message`都**存在**默认提示，不传则使用默认提示。\n> 5. 可传入支持`elementUI`封装的数据格式。\n\n### 组件 input 说明\n\n```javascript\n{\n  label: '输入框',\n  component: 'input',\n  show: () => true,\n  name: 'input',\n  rules: {\n    required: {\n      message: '请输入输入框'\n    }\n  },\n  options: {\n    slots: {\n      prefix: (data, h) => h('i', { class: 'el-icon-search' })\n    }\n  },\n  description: '这是一条说明'\n}\n```\n\n> 此处`slot`对象 key 需要和 input 框`slot`的`name`对应,否则将不会生效。可接受表单数据和[render 函数](https://cn.vuejs.org/v2/guide/render-function.html#%E5%9F%BA%E7%A1%80)进行渲染\n\n### 组件 render 说明\n\n以 `el-color-picker` 色彩选择器为例\n\n```javascript\n{\n  label: 'render组件',\n  component: 'render',\n  name: 'render',\n  dataSource: (formData, h) => {\n    return h(\"el-color-picker\", {\n      props: {\n        value: formData.render\n      },\n      on: {\n        change: val => {\n          this.$set(formData, 'render', val)\n        }\n      }\n    });\n  }\n}\n```\n\n> 此处`dataSource`接收当前表单数据和渲染函数，可通过此函数进行[render 函数](https://cn.vuejs.org/v2/guide/render-function.html#%E5%9F%BA%E7%A1%80)的渲染\n\n### 案例\n\n```javascript\n<template>\n  <als-block-form ref='mainForm' :formMap=\"formMap\" />\n</template>\n\n<script>\nexport default {\n  data () {\n    formMap: {\n      options: {\n        submitApi: axios.post('save')\n      },\n      formData: {\n        input: '',\n        number: 0,\n        textarea: '',\n        date: new Date(),\n        select: '1',\n        checkbox: ['1'],\n        radio: '1',\n        switch: 1,\n        render: ''\n      },\n      formComponents: [{\n        label: '输入框',\n        component: 'input',\n        name: 'input',\n        show: (formData) => Boolean(formData.id), // 当存在id时显示\n        rules: {\n          required: {\n            message: '请输入输入框'\n          }\n        },\n        listeners: {\n          change: value => console.log(value)\n        },\n        options: {\n          placeholder: '请输入输入框',\n          slots: {\n            prefix: (data, h) => h('i', { class: 'el-icon-search' })\n          }\n        }\n      },\n      {\n        label: '数字框',\n        component: 'number',\n        name: 'number',\n        show: () => true,\n        disabled: () => false,\n        rules: [],\n        description: '这是一个数字框'\n      },\n      {\n        label: '文本框',\n        component: 'textarea',\n        name: 'textarea',\n        show: () => true,\n        disabled: () => false,\n        options: {\n          autosize: { minRows: 1, maxRows: 3 }\n        }\n      },\n      {\n        label: '日期',\n        component: 'date',\n        name: 'date',\n        show: () => true,\n        disabled: () => false\n      },\n      {\n        label: '下拉框',\n        component: 'select',\n        name: 'select',\n        show: () => true,\n        disabled: () => false,\n        dataSource: [{\n          value: '1',\n          label: '下拉框',\n          disabled: true\n        },\n        {\n          value: '2',\n          label: '下拉框2',\n          disabled: false\n        }]\n      },\n      {\n        label: '复选框',\n        component: 'checkbox',\n        name: 'checkbox',\n        show: () => true,\n        disabled: () => false,\n        dataSource: [{\n          value: '1',\n          label: '复选框1'\n        },\n        {\n          value: '2',\n          label: '复选框2'\n        }]\n      },\n      {\n        label: '单选框',\n        component: 'radio',\n        name: 'radio',\n        show: () => true,\n        disabled: () => false,\n        dataSource: [{\n          value: '1',\n          label: '单选框1'\n        },\n        {\n          value: '2',\n          label: '单选框2'\n        }]\n      },\n      {\n        label: '开关',\n        component: 'switch',\n        name: 'switch',\n        show: () => true,\n        disabled: () => false,\n        options: {\n          activeValue: '1',\n          inactiveValue: '0'\n        }\n      },\n      {\n        label: '按钮',\n        component: 'button',\n        show: () => true,\n        listeners: {\n          click: _ => console.log(this.formMap.formData)\n        },\n        dataSource: [{\n          html: '<i class=\"el-icon el-icon-plus\"></i><span>按钮</span>',\n          type: 'primary',\n          style: 'width: 100%',\n          click: formData => console.log(formData)\n        }]\n      },\n      {\n        label: 'render组件',\n        component: 'render',\n        name: 'render',\n        show: () => true,\n        disabled: () => false,\n        dataSource: (data, h) => {\n          return h(\"el-color-picker\", {\n            props: {\n              value: this.formMap.formData.render\n            },\n            on: {\n              change: val => {\n                this.$set(this.formMap.formData, 'render', val)\n              }\n            }\n          });\n        }\n      }]\n    }\n  },\n\n  methods: {\n    /**\n     * 提交表单\n     */\n    handleBtnClick () {\n      this.$refs.mainForm.submitForm().then(res => {\n        console.log(res)\n      })\n    }\n  }\n}\n</script>\n```\n","tags":["als-block"],"categories":["als-block"]},{"title":"docker 镜像","url":"%2Fblog%2Fdocker%2Fdocker%E9%95%9C%E5%83%8F%2F","content":"## mysql \n\n### 获取镜像\n\n```\ndocker pull mysql\n```\n\n### 运行容器\n\n```\ndocker run\n-d\n-v $PWD/mysql/conf:/etc/mysql/conf.d\n-v $PWD/mysql/logs:/logs\n-v $PWD/mysql/data:/var/lib/mysql\n-e MYSQL_ROOT_PASSWORD=root\n-p 13306:3306\nmysql\n```\n> $PWD 为当前目录，设置时换成真实路径\n\n>- -d：在后台运行\n>- -p：容器的 3306 端口映射到宿主机 13306\n>- -v：容器的 /etc/mysql/conf.d 配置文件映射到宿主机 $PWD/mysql/conf\n>- -e：mysql root 用户的密码\n\n### navicat连接\n查看加密特性\n\n```\nselect Host,User,plugin from mysql.user;\n```\n\n如出现以下情况\n\n| Host | User | plugin |\n|:-----|:------|:------|\n| % | root | caching_sha2_password |\n\n则执行\n\n```\n ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'root';\n```\n> 最后的`root`为账号密码\n\n设置成功后就可以进行`navicat`连接\n\n## mongodb\n### 获取镜像\n\n```\ndocker pull mongo\n```\n\n### 运行容器\n```\ndocker run \n-d \n-v $PWD/mongodb/db:/data/db \n-p 27017:27017 \n--name mongodb \nmongo\n```\n>- -d：在后台运行\n>- -v：容器的 /data/db 数据配置文件映射到宿主机 $PWD/mongodb/db\n>- -p：容器的 27017 端口映射到宿主机 27017\n>- --name：容器的名字为 mongodb\n\n## jenkins\n### 获取镜像\n```\ndocker pull jenkins/jenkins\n```\n\n### 运行容器\n```\ndocker run \n-d \n-v $PWD/jenkins:/var/jenkins_home \n-p 13050:8080\n--name jenkins \njenkins/jenkins\n```\n> 与上面的说明一致\n\n### 进入容器\n```\ndocker exec -it [CONTAINER ID] /bin/bash\n```\n### 访问地址\n\n```\nhttp://localhost:13050\n```\n\n## gitlab\n\n### 获取镜像\n```\ndocker pull gitlab/gitlab-ce\n```\n\n> 镜像较大(1G左右),需要耐心等待\n\n### 运行容器\n```\n$ docker run \n-d  \n-p 443:443  # 把容器的http端口443映射到外部443端口\n-p 8008:80 \t# 把容器的web端口80映射到外部80端口\n-p 22:22 \t# 把容器的ssh端口22映射到外部22端口\n--name gitlab \n--restart always \n-v $PWD/config:/etc/gitlab \n-v $PWD/logs:/var/log/gitlab \n-v $PWD/data:/var/opt/gitlab \ngitlab/gitlab-ce\n```\n> --restart 设置重启方式，always 代表一直开启，服务器开机后也会自动开启的<br/>\n> 其他的与上面的说明一致<br />\n\n```\ndocker ps\n```\n\n> 可以看到 GitLab 已经在运行了，其他有一个属性 STATUS 为 health: starting，说明 gitlab 的服务正在启动中，还没有启动完毕。等这个状态变成 healthy 时则说明已经部署完成，可以访问了\n\n### 配置\n1. 如果出现 502 错误\n\n\t```\n\tdocker exec -it gitlab update-permissions\n\t```\n\n1. 修改$PWD/gitlab/etc/gitlab.rb\n\n\t```\n\t# 配置http协议所使用的访问地址,不加端口号默认为80\n\texternal_url 'http://192.168.0.101'\n\t\n\t# 配置ssh协议所使用的访问地址和端口\n\tgitlab_rails['gitlab_ssh_host'] = '192.168.0.101'\n\tgitlab_rails['gitlab_shell_ssh_port'] = 222 # 此端口是run时22端口映射的222端口\n\t```\n\n2. 修改$PWD/gitlab/data/gitlab-rails/etc/gitlab.yml\n\n\t```\n\t找到关键字 * ## Web server settings * \n\t将host的值改成映射的外部主机ip地址和端口\n\t\n\t## GitLab settings\n\tgitlab:\n      ## Web server settings (note: host is the FQDN, do not include http://)\n      host: 192.168.0.101\n      port: 22\n      https: false\n\t```\n\n因为是容器，所以要进入到gitlab容器中执行命令\n\n```\ndocker exec -ti gitlab /bin/bash\n\ngitlab-ctl reconfigure # 修改配置\ngitlab-ctl restart\t   # 重启\ngitlab-ctl status\n```\n\n### 访问地址\n\n```\nhttp://192.168.0.101:8008\n```\n\n## nginx\n### 获取镜像\n```\ndocker pull nginx\n```\n\n### 运行容器\n\n```\ndocker run -d -p 80:80  --name nginx nginx\n```\n\n将容器中 nginx 的配置文件复制到 . 当前目录下\n\n```\ndocker cp nginx:/etc/nginx .\n```\n\n修改配置文件后即可停止并删除 nginx 服务\n\n```\ndocker stop nginx\ndocker rm nginx\n```\n\n目录映射 ---- 使修改的配置生效\n\n```\ndocker run\n-d\n-v $PWD/nginx:/etc/nginx\n-v $PWD/nginx/html:/usr/share/nginx/html\n-p 80:80\nnginx\n```\n> 与上面的说明一致\n\n### 访问地址\n\n```\nhttp://localhost\n```\n\n## docker常用命令\n```\ndocker images\t\t\t\t\t\t\t// 查看已有的docker镜像\ndocker ps\t\t\t\t\t\t\t\t// 查看所有运行中容器\ndocker ps -a\t\t\t\t\t\t\t// 查看所有状态的容器\ndocker start [ID]       \t\t\t\t// 启动指定ID容器\ndocker stop [ID]\t    \t\t\t\t// 停止指定ID容器\ndocker restart [ID]\t    \t\t\t\t// 重启指定ID容器\ndocker rm [ID]\t\t    \t\t\t\t// 删除指定ID容器\ndocker rmi [NAME]       \t\t\t\t// 删除特定镜像\ndocker exec -it [CONTAINER ID] /bin/bash //进入容器\n\n```\n\n\n## docker后私有服务部署\n\n### 推送\n\n注册阿里云账号并进入[容器镜像服务](https://cr.console.aliyun.com/cn-hangzhou/instances/repositories)\n\n1. 创建命名空间\n2. 创建镜像仓库\n3. 点击镜像仓库名称进入基本信息\n\n\n本地打包docker镜像\n\n```\ndocker build -t demo .\n```\n\n\n*根据仓库的基本信息描述*将镜像推送到Registry\n\n推送成功后切换至菜单镜像版本查看镜像信息,如果存在推送的版本信息则说明推送成功\n\n### 拉取\n登录私有服务器\n\n1. 从Registry中拉取镜像\n\n\t```\n\tdocker pull registry.cn-hangzhou.aliyuncs.com/demo_alisdon/demo:[镜像版本号]\n\t```\n\n2. 远程运行\n\n\t```bash\n\tdocker run -d -p 80:80 registry.cn-hangzhou.aliyuncs.com/demo_alisdon/demo:latest\n\t```\n\t\n\t> 待验证","tags":["docker基础"],"categories":["docker"]},{"title":"微信小程序和移动网页的相爱相杀","url":"%2Fblog%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%BD%91%E9%A1%B5%E7%9A%84%E7%9B%B8%E7%88%B1%E7%9B%B8%E6%9D%80%2F","content":"\n两者身为同一个时代的产物，存在太多志同道合、“异性相吸”的魔力，又有着不拘一格、“同性相斥”的魅力。但可以确定的是，两者身上都有一种为了实现世界统一的魄力。\n\n## 生死之战\n\n| pk 项 | h5 | mp-weixin |\n|:---- | ---- | --- |\n| 运行环境 | 浏览器 | 微信 |\n| 系统API权限 | 弱 | 强 |\n| 分享朋友圈 | 能 | 不能 |\n| 扫码识别 | 能 | 能 |\n| 支付能力 | 多种 | 微信支付 |\n| 使用流畅/平滑 | 一般 | 良好 |\n| 入口数量 | 少 | 多 |\n| 专属入口 | 无 | 有 |\n| 简易功能成本 | 低 | 低 |\n| 系统功能成本 | 高 | 低 |\n| 迭代周期 | 短 | 较长 |\n| 外部限制 | 较少 | 多 |\n\n\n## 跨界合作\n\n### 准备工作\n\n1. 注册小程序账号必须为企业的，个人类型的小程序暂不支持使用\n2. 微信 6.7.2 版本以上(目前安卓最新版 7.0.12/苹果 7.0.11)\n3. 需登录小程序管理后台配置业务域名\n4. 基础库1.6.4以上\n\n### 命令部署\n\n1. 业务域名中配置的就是小程序以及 H5 和 H5 中引用 iframe 的域名\n2. 将校验文件放置在将要嵌套的业务域名的根目录\n\n### 统一战线\n\n1. 嵌入的 h5 不能调用支付接口\n2. 嵌入的 h5 拿不到分享成功失败的信息\n\n### 互帮互助\n\n1. mp -> h5  使用 `src ` 地址传值\n2. h5 -> mp `postMessage`, `web-view` 绑定 `bindmessage` 进行接收\n3. weixinjssdk\n\n> tips: `bindMessage`为网页向小程序 `postMessage ` 时，会在特定时机（小程序后退、组件销毁、分享）触发并收到消息\n\n### 矛盾冲突\n\n![](./WX20200318-231151@2x.png)","tags":["小程序"],"categories":["小程序"]},{"title":"text-align 两端对齐","url":"%2Fblog%2Fcss%2Ftext-align-%E4%B8%A4%E7%AB%AF%E5%AF%B9%E9%BD%90%2F","content":"### \n## 简单总结\n都知道想实现两端对齐可以使用 `text-align:justify`，但是每次使用或多或少都会出现一些问题。对于这些问题我们就来总结一下\n\n```\ntext-align: justify；\n```\n\n> 兼容性好，能兼容 ios，但只针对非尾行即最后一行之前的文本\n\n```\ntext-align-last: justify；\n```\n\n> 兼容性差，不兼容 ios，只针对尾行的文本\n\n```\nwhite-space: nowrap;\n```\n\n> 设置该属性后不生效\n\n**只有一行的时候那就需要特殊的处理一下了**\n\n1. 使用 `text-align-last`\n2. 手动添加一行最为最后行，并将其隐藏\n\n## 小程序端实现\n\nwxml\n\n```\n<view class=\"foods\">\n   <view class=\"eat\">\n      <view>早上吃什么<text></text></view>: 洗衣粉\n   </view>\n   <view class=\"eat\">\n      <view>午餐呢<text></text></view>: 肥皂\n   </view>\n   <view class=\"eat\">\n      <view>最重要的晚餐<text></text></view>: 沐浴露\n   </view>\n</view>\n```\n\nwxss\n\n```\n.eat {\n   line-height:100rpx\n}\n.eat + .eat {\n   border-top:1rpxsolid #f5f5f5\n}\n.eat view {\n   height:100rpx;\n   width:240rpx;\n   display: inline-block;\n   text-align:justify;\n   vertical-align:top\n}\n.eat view text {\n   display: inline-block;\n   height:0;\n   width:100%  /* 换行 */\n}\n```\n\n\n","tags":["css"],"categories":["css"]},{"title":"mac 创建 svn 仓库","url":"%2Fblog%2F%E5%85%B6%E4%BB%96%2Fmac%20%E5%88%9B%E5%BB%BA%20svn%20%E4%BB%93%E5%BA%93%2F","content":"团队开发中代码版本管理是一个必不可少的工具，本篇文章将简单介绍如何在 macOS 中搭建 svn 版本服务\n\n## 安装 svn\n\n### 检查安装\n\n开始之前，先检查系统中是否已经安装了 svn\n\n```\nsvn --version\n```\n\n如果出现版本信息，则表示已经安装成功，可跳过以下安装步骤至创建仓库\n\n### 开始安装\n\n在 macOS 中，一般我建议使用 Homebrew 进行包管理，至于 Homebrew 本篇文章不做描述，不了解的可以自行百度\n\n```\nbrew install svn\n```\n\n安装成功后，建议再检查安装一次，以确保能够正常使用\n\n## 创建仓库\n\n在安装成功之后咱们就可以创建代码仓库了\n\n```\nsvnadmin create ./svn/repository/svn_test\n```\n\n> ./svn/repository/svn_test 为你想存放 svn 仓库的文件地址，svn_test 为当前仓库名称，这里换成你自己的即可\n\n正常情况下，你将可以在你刚刚输入的目录中看到新生成的文件夹了，但是 macOS 升级成 macOS catalina 10.15 后将会出现\n\n```\nzsh: command not found: svnadmin\n```\n\n这个是因为 Apple 在这个版本中移除了 svn 管理，所以导致了 svn 相关的命令失效，这里多说一句 Apple 的这个更新可能会导致一部分的软件需要重新安装，如果遇到了不能正常使用的软件，大家不妨重新安装试一试\n\n## 配置权限\n\n安装成功后，进入到你刚刚设置的目录中，如我们设置的 ./svn/repository/svn_test，你将看见大致（只展示我们需要的部分）如下的目录\n\n```\n|-- conf\n|---- authz\n|---- hooks-env.tmpl\n|---- passwd\n|---- svnserve.conf\n|-- db\n|-- hooks\n|-- locks\n|-- format\n|-- README.txt\n```\n\n### 权限\n打开 conf 下的 svnserve.conf 文件并做以下修改\n\n```\n# anon-access = read\nanon-access = read\n\n# auth-access = write\nauth-access = write\n\n# password-db = passwd\npassword-db = passwd\n\n# authz-db = authz\nauthz-db = authz\n\n```\n\n> 1. 以上修改为上一行为原始配置，下一行为修改后的配置\n> 2. 以上配置信息的含义请自行百度\n\n### 用户\n打开 conf 下的 passwd 文件并做以下修改\n\n```\n[users]\n\nsvnuser1 = 123456\nsvnuser2 = 123456\n```\n> 添加用户名为 svnuser1，密码为 123456 和用户名为 svnuser2，密码为 123456 的两位用户\n\n### 分组授权\n打开 conf 下的 authz 文件并做以下修改\n\n```\n[groups]\nsvngroup = svnuser1,svnuser2\n\n[/]\n@svngroup=rw\n```\n> rw为可读可写\n\n## 启动服务\n返回控制台输入\n\n```\nsvnserve -d -r ./svn/repository\n```\n\n> 这里需要控制所建仓库地址，不需要进行至仓库名称\n\n如果控制台没有报错则说明启动成功\n\n## 连接服务\n启动成功后，我们将远程的代码进行拉去，尽管现在没有代码，我们也可以先将仓库拉下来用于后续代码管理\n\n```\nsvn checkout svn://localhost/svn_test --username=svnuser1 --password=123456 ./code\n```\n\n> 将代码从 svn_test 下载到 ./code 目录下\n\n## 关闭服务\n因为 svn 服务就是一个进程，所以可以通过杀进程的方式进行管理\n\n### 方法一（推荐）：\n\n打开系统软件《活动监视器》 选择 svnserve 进行关闭即可。\n\n### 方法二\n\n获取 svn 的 PID\n\n```\nps -ef|grep svn\n```\n\n杀掉进程\n\n```\nkill -9 $1\n```\n\n> $1 为上面获取到的 PID\n\n## 至此\n这样一个 svn 代码管理仓库就搭建完成了，我们就可以用 svn 来进行我们的代码管理","tags":["svn"],"categories":["其他"]},{"title":"uni-app","url":"%2Fblog%2F%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%2Funi-app%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%2F","content":"# 在uni-app进行多端开发总结\n\n## H5\n\n## 非H5\n1. 不可对uni进行属性添加\n2. 不可使用slot属性\n3. 不可上传非图片文件\n\n\n### 微信小程序\n\n### 支付宝小程序\n1. 不可使用高度100%\n2. 需要将导航栏的背景设置成#fff才可以显示标题\n","tags":["uni-app"],"categories":["混合开发"]},{"title":"小程序获取特定页二维码","url":"%2Fblog%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%8E%B7%E5%8F%96%E7%89%B9%E5%AE%9A%E9%A1%B5%E4%BA%8C%E7%BB%B4%E7%A0%81%2F","content":"\n# 准备工作\n1. 确保页面路径存在*app.json*文件中\n2. 获取小程序的*AppId*和*AppSecret*\n3. 下载postman工具\n\n# 开始获取\n\n微信提供了「获取小程序二维码」的接口。\n通过这个接口，商家和开发者能够制作进入不同页面的小程序二维码，而不会限定扫码进入小程序主页。\n\n## 获取Access Token\n\n利用postman工具根据准备的**AppID**和**AppSecret**，获取 **Access Token**。 使用**get**方式请求地址*https://api.weixin.qq.com/cgi-bin/token*，传入以下参数\n\n```\n{\n  grant_type: client_credential,\n  appid: 你的AppId,\n  secret: 你的AppSecret\n}\n```\n\n点击**Send**出现图中所示则表示请求成功，其中**access_token**就是我们需要的值\n\n![](./getAccessToken.png)\n\n## 获取二维码\n\n微信提供了两个**POST**获取小程序二维码的接口\n\n- 获取最新的「菊花式」小程序码，可以使用这个接口：\n\n```\nhttps://api.weixin.qq.com/wxa/getwxacode?access_token=ACCESS_TOKEN。\n```\n\n- 获取经典的「狗皮膏药式」QR 码，可以使用这个接口：\n\n```\nhttps://api.weixin.qq.com/cgi-bin/wxaapp/createwxaqrcode?access_token=ACCESS_TOKEN\n```\n\n在postman中输入以上地址后需要**修改POST请求体中的请求方式为raw, 并修改JSON请求体为**\n\n```\n{\"path\": \"pages/discover/article/index?type=1\"}\n```\n\n最终配置如下\n![](./getQRParams.png)\n![](./getQRBody.png)\n\n如果请求成功则会返回小程序的二维码图片\n\n![](./getSuccess.png)","tags":["微信小程序"],"categories":["小程序"]},{"title":"用vertical-align实现垂直水平居中","url":"%2Fblog%2Fcss%2FverticalAlign%E7%AE%80%E4%BB%8B%2F","content":"\n# 简介\nvertical-align属于css中用的比较少的一个属性，其原因就是它比较难于理解，但它是同时也是一个比较重要的属性。首先引用一段对它的定义说明\n\n> 该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。允许指定负长度值和百分比值。这会使元素降低而不是升高。在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式。\n\n对此我们得到了两层重要信息\n\n1. **该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐**。注意其中的行内元素，说明该属性**只对行内元素有效**\n2. 表格的**td**中直接添加`vertical-align: middle`的样式让其`垂直居中对齐`，添加`vertical-align: top`顶部对齐。\n\n> **Tips:** 该属性与水平对齐方式属性`text-align`不同，使用对象是linebox下的行内元素\n\n> **什么是Line Box**\n\n> 每一行称为一条Line Box，它又是由这一行的许多inline-box组成，它的高度可以直接由line-height决定，line boxes的高度垂直堆叠形成了containing box的高度，就是我们见到的div或是p标签之类的高度了\n\n# baseline\n[传送门](http://www.cnblogs.com/starof/p/4512284.html?utm_source=tuicool&utm_medium=referral)\n\n# 实际应用\n\n垂直居中\n\n> 为父元素设定一个伪元素`::after`,其高度为父元素的高度并设置`display:inline-block`让其成为lineBox元素,将`::after`设定为`vertical-align:middle`即可撑开lineBox，同时lineBox的baseline为父元素高度一半的位置。然后设定子元素`vertical-align:middle`，即可实现居中。\n\n> 考虑兼容性的话，这里需要使用一些hack，由于IE8不支持::after伪元素，所以需要一个span来替代。而display:inline-block亦需要hack。\n\n代码示例：\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n    <style>\n        .masker-model {\n            background-color: #000;\n            opacity: .6;\n            z-index: 999;\n            position: fixed;\n            left: 0;\n            right: 0;\n            top: 0;\n            bottom: 0;\n            text-align: center;\n        }\n        .masker-model::after {\n            content: '';\n            display: inline-block;\n            height: 100%;\n            vertical-align: middle;\n        }\n        .loading {\n            color: #fff;\n            display: inline-block;\n            vertical-align: middle;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"masker-model\">\n        <div class=\"loading\">loading....</div>\n    </div>\n</body>\n</html>\n```\n\n\n\n","tags":["css"],"categories":["css"]},{"title":"创建简单的npm脚手架","url":"%2Fblog%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2F%E5%88%9B%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84npm%E8%84%9A%E6%89%8B%E6%9E%B6%2F","content":"\n## 前言\nvue-cli， webpack-cli 等脚手架是不是用起来爱不释手？自己写了个模版每次来回复制粘贴代码是不是很难维护？如果你是对前端、Node操作有一定的了解，同时也存在以上疑问，那就请尽情阅读尝试吧！\n\n> 本篇文章按照`al-block-cli`举例, `al-block-cli`是一个基于`vue`和`elementUI`而集成的一个开发模版，可安装进行使用\n\n## 依赖\n\n1. [Commander.js](https://github.com/tj/commander.js) 命令行工具\n2. [download-git-repo](https://github.com/flipxfx/download-git-repo) git仓库代码下载\n3. [chalk](https://github.com/chalk/chalk) 命令行输出样式美化\n4. [Inquirer.js](https://github.com/SBoudrias/Inquirer.js) 命令行交互\n5. [ora](https://github.com/sindresorhus/ora)命令行加载中效果\n\n根据上方的依赖插件即可以看出，**其实脚手架就是一个利用终端命令将仓库中的代码拉取到本地的工具**。*所以还没有模版代码的同学赶紧去创建个*\n\n## 项目准备\n\n### Npm初始化\n\n```\n$ npm init\n```\n\n> 根据提示完成初始化搭建，如果不清楚如何配置可以**直接回车**\n\n### 安装依赖\n\n```\n$ npm install commander download-git-repo chalk inquirer ora --save\n```\n### 构建结构\n\n1. 创建`bin`和`commands`文件夹以及配置文件`templates.json`。\n2. 在`bin`目录下创建入口文件`al-block-cli`，在`commands`目录下创建命令指示文件`init.js`\n\n> `bin`文件夹为可执行命令入口目录，`commands`则负责编写一些命令交互，\n\n### 最终目录结构\n\n```\n- al-block-cli\n| - bin\n  | - al-blocl-cli\n| - commands\n  | - init.js\n| - node_modules\n| - package.json\n| - templates.json\n```\n## 编写代码\n\n### 配置文件\n\n输入默认需要的配置，如这里需要`github `的仓库地址和命令行的名称\n\n```\n{\n  \"init\": {\n    \"name\": \"init\",\n    \"path\": \"Alisdon/al-block-template\"\n  }\n}\n```\n\n### 入口文件\n\n打开`al-block-cli`文件，并在其第一行加入\n\n```\n#! /usr/bin/env node\n```\n> 此行为了防止操作系统用户没有将**node**装在默认的**/usr/bin**路径里。当系统看到这一行的时候，首先会到env设置里查找node的安装路径，再调用对应路径下的解释器程序完成操作。\n\n```\n#!/usr/bin/env node\n\nprocess.env.NODE_PATH = __dirname + '/../node_modules/';\n\nconst program = require('commander');\n\nprogram\n  .version(require('../package').version);\n\nprogram\n  .usage('<command>');\n\nprogram.command('init')\n  .description('create a new project')\n  .alias('i')\n  .action(() => {\n    require('../commands/init')\n  });\n\nprogram.parse(process.argv);\n\nif(!program.args.length){\n  program.help()\n}\n```\n### 命令交互\n\n打开表示命令`init`的`init.js`文件\n\n```\nconst { prompt } = require('inquirer');\nconst program = require('commander');\nconst chalk = require('chalk');\nconst download = require('download-git-repo');\nconst ora = require('ora');\nconst fs = require('fs');\n\nconst option =  program.parse(process.argv).args[0];\nconst question = [\n  {\n    type: 'input',\n    name: 'name',\n    message: 'Project name',\n    default: typeof option === 'string' ? option : 'al-block-template',\n    filter (val) {\n      return val.trim()\n    },\n    validate (val) {\n      const validate = (val.trim().split(\" \")).length === 1;\n      return validate || 'Project name is not allowed to have spaces ';\n    },\n    transformer (val) {\n      return val;\n    }\n  },\n  {\n    type: 'input',\n    name: 'description',\n    message: 'Project description',\n    default: 'Vue project',\n    validate () {\n      return true;\n    },\n    transformer(val) {\n      return val;\n    }\n  },\n  {\n    type: 'input',\n    name: 'author',\n    message: 'Author',\n    default: '',\n    validate () {\n      return true;\n    },\n    transformer(val) {\n      return val;\n    }\n  }\n];\n\nmodule.exports = prompt(question).then(({name, description, author}) => {\n  const gitPlace = require('../templates').init.path;\n  const projectName = name;\n  const spinner = ora('Downloading please wait...');\n\n  spinner.start();\n  download(`${gitPlace}`, `./${projectName}`, (err) => {\n    if (err) {\n      console.log(chalk.red(err));\n      process.exit()\n    }\n\n    fs.readFile(`./${projectName}/package.json`, 'utf8', function (err, data) {\n      if(err) {\n        spinner.stop();\n        console.error(err);\n        return;\n      }\n\n      const packageJson = JSON.parse(data);\n      packageJson.name = name;\n      packageJson.description = description;\n      packageJson.author = author;\n\n      fs.writeFile(`./${projectName}/package.json`, JSON.stringify(packageJson, null, 2), 'utf8', function (err) {\n        if(err) {\n          spinner.stop();\n          console.error(err);\n        } else {\n          spinner.stop();\n          console.log(chalk.green('project init successfully!'))\n          console.log(`\n            ${chalk.yellow(`cd ${name}`)}\n            ${chalk.yellow('npm install')}\n            ${chalk.yellow('npm run dev')}\n          `);\n        }\n      });\n    });\n  })\n});\n\n```\n\n## 测试发布\n\n### 测试\n\n至此，一个简单的脚手架（壳）就已经完成了，为了查看在编写过程中是否出错，我们现在本地进行测试\n\n```\n$ node bin/al-block-cli\n```\n\n如果没有报错，出现了熟悉的命令行，那就说明成功了\n\n### 发布\n\n发布之前我们需要做个小调整，观察其他脚手架工具他们都是以自己独特的`key`值进行搭建，对此我们可以在`package.json`里面配置`bin`对象\n\n```\n\"bin\": {\n\t\"al-block-cli\": \"bin/al-block-cli\"\n}\n```\n\n> 这里需要注意`bin/`后面的`al-block-cli`,这个路径是由[入口文件](#入口文件)的路径确定，如果你是建的`al-block-cli.js`则此处应该配置`bin/al-block-cli.js`，本篇是创建的没有后缀名的文件\n\n修改后生成的最终`package.json`\n\n```\n{\n  \"name\": \"al-block-cli\",\n  \"version\": \"1.0.0\",\n  \"description\": \"al-block-cli\",\n  \"keywords\": [\n    \"vue\",\n    \"al-block\",\n    \"al-block-cli\"\n  ],\n  \"scripts\": {\n    \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\"\n  },\n  \"bin\": {\n    \"al-block-cli\": \"bin/al-block-cli\"\n  },\n  \"preferGlobal\": true,\n  \"author\": \"Alisdon [920124512@qq.com]\",\n  \"license\": \"MIT\",\n  \"dependencies\": {\n    \"chalk\": \"^2.4.1\",\n    \"commander\": \"^2.19.0\",\n    \"download-git-repo\": \"^1.1.0\",\n    \"inquirer\": \"^6.2.1\",\n    \"ora\": \"^3.0.0\"\n  }\n}\n```\n\n对比文件内容，如果没有问题我们就开始发布了\n\n```\n$ npm login\n$ npm publish\n```\n\n","tags":["node"],"categories":["服务端"]},{"title":"用于mmzsblog网站博客开发","url":"%2Fblog%2Fmmzsblog%2Fmmzsblog%2F","content":"\n## 前期准备\n\n以下代码均在系统命令行(*非node环境下的命令行*)下完成。\n\n- `cmd`打开*window系统*命令行\n- 直接在*mac系统*中打开`终端`\n\n### 安装nodeJs\n\n前往 [node官方下载地址](https://nodejs.org/en/download/)下载对应版本进行安装\n\n#### 检测安装状态\n\n```\n$ node -v\n```\n出现版本信息则表示安装成功\n### 安装git\n\n前往 [git官方下载地址](https://git-scm.com/downloads)下载对应版本进行安装\n#### 检测安装状态\n\n```\n$ git --version\n```\n出现版本信息则表示安装成功\n### 安装hexo\n\n```\n$ npm install -g hexo-cli\n```\n> 此步骤需要将`nodejs `安装成功后才可进行，否则将报`npm `命令不存在的错误\n\n#### 检测安装状态\n\n```\n$ hexo version\n```\n出现版本信息则表示安装成功\n\n\n## 克隆代码\n### 克隆框架代码\n\n```\n$ git clone git@118.24.19.22:/mmzsblog/blog.git\n```\n> 此步骤需要将`git`安装成功后才可进行，否则将报`git `命令不存在的错误。后续在**新增文章之前需要先更新框架代码**。拉取成功后默认文件夹名称为`blog`，本篇文章以`blog`为文件夹名称举例\n\n### 克隆主题代码\n\n```\n$ cd blog\n$ git clone git@118.24.19.22:/mmzsblog/theme.git themes/pure\n```\n\n> 此步骤需要将`git`安装成功后才可进行，否则将报`git `命令不存在的错误，由于框架代码中主题代码不能提交成功，所以将其分开获取。此代码只需要拉取一次，后续**新增文章之前可不再更新**\n\n## 安装依赖\n```\n$ npm install\n```\n执行成功上述操作将出现图中目录文件\n![](./hexom.png)\n\n## 开始创建\n### 新建文章\n创建文章之前先更新仓库代码，然后再创建一篇新文章\n\n```\n$ git pull\n$ hexo new 你的文章名称\n```\n\n打开**当前文件夹**下的`source/_post`目录，找到新建的文件*（一般是根据上方新建的文章名称作为文件名称）*进行编写\n\n### 静态图片的处理\n\n1. 放到`source/images`文件中，在文章中需要进行`![](/images/xxx.jpg)`的引入\n2. 直接放到和文章名称相同的文件夹中，在文章中需要进行`![](./xxx.png)`的引入\n\n### 预览文章\n```\n$ hexo server\t\t简写\t\thexo s\n```\n![](./hexos.png)\n\n> 打开浏览器输入`http://localhost:4000`进行访问。如果出现白板且控制台出现了`index.html`相关的问题则是由于没有获取主题导致的，需要前往<a href=\"#克隆主题代码\">克隆主题文件</a>\n\n## 发布文章\n由于`mmzsblog`是通过`github`进行重定向，所以将不做清理静态文件的操作，避免提交后需要重新设置的重复操作\n\n### 打包编译\n```\n$ git pull\n$ hexo generate \t 简写\t\thexo g\n```\n\n![](./hexog.png)\n\n### 发布提交\n```\n$ hexo deploy\t\t 简写\t\thexo d\n```\n\n![](./hexod.png)\n\t\n如果出现以上提示则说明提交成功，隔几分钟后刷新[https://blog.mmzsblog.cn](https://blog.mmzsblog.cn)即可查看刚刚新增的文章\n\t\n## 提交代码\n\n提交框架代码，避免多人开发时不同步的问题\n\n```\n$ git status\n$ git add .\n$ git commit -m '新增一篇文章'\n$ git push\n```","tags":["mmzsblog"],"categories":["mmzsblog"]},{"title":"mac下安装nginx","url":"%2Fblog%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2Fmac%20%E4%B8%8B%E5%AE%89%E8%A3%85nginx%2F","content":"\n## 初识nginx\n相信大多数同学已经听说了nginx这个东东，会不会很多同学和我一样一开始接触nginx的时候不知道它是什么？它能干什么？如果需要启服务，完全可以用node，为什么还需要使用nginx？\n\n对以上问题，我先引用一下官方对nginx的介绍\n\n> \"Nginx是一款轻量级的HTTP服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的IO性能，时常用于服务端的反向代理和负载均衡。\"\n\n### nginx的应用场景\n\n 1. **http服务器**。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。\n 2. **虚拟主机**。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。\n 3. **反向代理，负载均衡**。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。\n\n### nginx的优点\nnginx的优点在应用场景中已有体现，比如上面提到的反向代理，负载均衡功能。除此之外还有以下优势\n\n- **支持海量高并发**：采用IO多路复用epoll。官方测试Nginx能够支持5万并发链接，实际生产环境中可以支撑2-4万并发连接数。\n- **内存消耗少**：在主流的服务器中Nginx目前是内存消耗最小的。\n- **配置文件简单**：网络和程序配置通俗易懂，即使非专业运维也能看懂。\n- **支持热部署**：这对于我们前端的同学来说，使用惯webpack的热更新，对热更新的支持，无疑是吸引了一大波同学（我就算其中一个，啊哈哈）\n\n![](/blog/images/nginx-c.jpg)\n\n## 安装nginx\n前面铺垫了这么多，现在终于进入主题了。本教程是使用homebrew进行安装，未安装brew的同学请自行安装\n\n\tbrew install nginx\n\n![](/blog/images/nginx-install.png)\n### 配置文件地址\n安装成功后需要对配置文件进行个性化定制，本教程提供大部分时间需要修改的配置，配置文件在如下地址处\n\n*/usr/local/etc/nginx/nginx.conf*\n\n### 默认根目录\n是否想知道网址访问的哪份文件呢？来，我们一起打开它\n\n*/usr/local/var/www/*\n\n## 启动重启关闭\n成功安装后，我们肯定就是来使用nginx了，你可使用\n\n\tnginx \n\t\n**直接启动**或者使用\n\n\tnginx -s reload|reopen|stop|quit \n\n**重新加载配置|重启|快速停止|安全关闭**\n\n启动成功后，我们就只需要在浏览器中访问服务（地址）就好了\n\n*http://localhost:8080*\n\n![](/blog/images/nginx-open.png)\n\n## 自定义配置\n### 修改访问端口\n默认8080被占用了？或者你看8080端口不爽？来，我们一起灭了它\n\n![](/blog/images/nginx-port.png)\n\n### 修改默认根目录\n修改完8080，你是否觉得用默认的网站根目录很难找？是不是想换成自己熟悉的目录呢？\n\n![](/blog/images/nginx-path.png)\n\n> tips: 配置文件里`location /` 里面的`root`,将`yourname`换成你电脑的用户名\n\n## 异常处理\n### Permission问题\n这种问题都是没有权限引起的，执行代码前加上sudo即可\n\n![](/blog/images/nginx-permission.png)\n\n### Forbidden\n修改了默认的网站根目录，出现问题时避免不了的。但是怎么办呢？这种问题一般是没有找到对应的文件，要不就是权限的问题\n\n1. 查看目录下是否存在`index.html`或者`index.htm`\n\n2. 修改配置文件第一行为 `user root owner;` 然后重启\n\n### File not find\n同上 <a href=\"#Forbidden\"> Forbidden </a>的解决方案\n\n## 卸载nginx\n好了，最后，如果你还是觉得nginx用起来不爽，更喜欢node，Apache什么的，勇敢的卸载它吧\n\n\tbrew uninstall nginx\n","tags":["nginx"],"categories":["服务端"]},{"title":"安装hexo","url":"%2Fblog%2F%E5%85%B6%E4%BB%96%2F%E5%AE%89%E8%A3%85hexo%2F","content":"\n### 安装hexo \n\n```\n$ npm install -g hexo-cli\n```\n\n### 初始化项目 \n\n```\n$ hexo init <folder>\n$ cd <folder>\n$ npm install``\n```\n\n### 启动项目 \n```\n$ hexo server\n```\n\n### 更换主题 \n选择喜欢的[主题](https://hexo.io/themes/)并根据选择的主题进行更换，并将_config.yml中的theme主题替换成在文件夹theme中的文件名称, 添加主题中需要的图片等素材","tags":["其他"],"categories":["其他"]},{"title":"hexo书写一篇文章","url":"%2Fblog%2F%E5%85%B6%E4%BB%96%2F%E7%94%A8hexo%E5%86%99%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%2F","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate (hexo g)\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy (hexo d)\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","tags":["其他"],"categories":["其他"]},{"title":"linux下实现无密操作git","url":"%2Fblog%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%2Flinux%E4%B8%8B%E5%AE%9E%E7%8E%B0%E6%97%A0%E5%AF%86%E6%93%8D%E4%BD%9Cgit%2F","content":"\n### linux服务端配置\n\n**linux安装git**\n\n\tyum install -y git\n\n**创建用户git**\n\n\tgroupadd git\n\tadduser git -g git\n\t\n**配置linux权限问题及创建authorized_keys文件**\n\n\tcd /home/git\n\tmkdir .ssh\n\tchmod 700 .ssh\n\ttouch .ssh/authorized_keys\n\tchmod 600 .ssh/authorized_keys\n\tcd /home\n\tchown -R git:git git\n\n\tTips:后续的git clone如果需要密码，很有可能是git用户没有访问authorized_keys文件的权限\n\n**创建git仓库文件夹**\n\n\tcd /home\n\tmkdir gitTest\n\tchown git:git gitTest //赋予git用户权限\n\n**初始化git仓库**\n\n\tcd gitTest\n\tgit init --bare gitTest.git\n\n**把仓库所属用户改为git**\n\n\tchown -R git:git gitTest.git\n\n**创建post-receive文件（若不使用git自启动属性可不操作）**\n\n\tvim ~/gitTest.git/hooks/post-receive\n\n**post-receive文件内容（若不使用git自启动属性可不操作）**\n\n\t#！/bin/sh\n\tgit --work-tree=/usr/share/nginx/html/blog --git-dir=/home/gitTest/gitTest.git checkout -f\n\n**设置权限（若不使用git自启动属性可不操作）**\n\n\tchmod +x ~/gitTest.git/hooks/post-receive\n\n### **创建客户端口令**\n\n\tssh-keygen -t rsa -C '你的邮箱'\n\n### **设置免密登录口令**\n\n将id_rsa.pub中的内容写到服务器的authorized_keys文件中。\n\n\tcat id_rsa.pub >> authorized_keys\n\n\n### **请求git仓库**\n\n\tgit clone git@ip:/home/gitTest/gitTest.git","tags":["git"],"categories":["服务端"]}]