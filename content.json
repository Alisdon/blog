{"meta":{"title":"Alisdon Blog","subtitle":"Time is the most precious wealth of all wealth","description":"wlf的博客","author":"Alisdon","url":"https://alisdon.github.com"},"pages":[{"title":"Repositories","date":"2018-11-21T07:05:50.334Z","updated":"2018-11-21T02:34:17.090Z","comments":false,"path":"repository/index.html","permalink":"https://alisdon.github.com/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2018-11-21T07:05:50.390Z","updated":"2018-11-21T02:34:17.089Z","comments":false,"path":"categories/index.html","permalink":"https://alisdon.github.com/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2018-11-21T07:05:50.403Z","updated":"2018-11-21T02:34:17.089Z","comments":false,"path":"about/index.html","permalink":"https://alisdon.github.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"友情链接","date":"2018-11-21T07:05:50.348Z","updated":"2018-11-21T02:34:17.089Z","comments":true,"path":"links/index.html","permalink":"https://alisdon.github.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-11-21T07:05:50.319Z","updated":"2018-11-21T02:34:17.090Z","comments":false,"path":"tags/index.html","permalink":"https://alisdon.github.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"创建简单的npm脚手架","slug":"创建简单的npm脚手架","date":"2018-12-18T08:57:18.000Z","updated":"2018-12-18T09:18:37.488Z","comments":true,"path":"node/创建简单的npm脚手架/","link":"","permalink":"https://alisdon.github.com/node/创建简单的npm脚手架/","excerpt":"","text":"前言vue-cli， webpack-cli 等脚手架是不是用起来爱不释手？自己写了个模版每次来回复制粘贴代码是不是很难维护？如果你是对前端、Node操作有一定的了解，同时也存在以上疑问，那就请尽情阅读尝试吧！ 本篇文章按照al-block-cli举例, al-block-cli是一个基于vue和elementUI而集成的一个开发模版，可安装进行使用 依赖 Commander.js 命令行工具 download-git-repo git仓库代码下载 chalk 命令行输出样式美化 Inquirer.js 命令行交互 ora命令行加载中效果 根据上方的依赖插件即可以看出，其实脚手架就是一个利用终端命令将仓库中的代码拉取到本地的工具。所以还没有模版代码的同学赶紧去创建个 项目准备初始化1npm init 根据提示完成初始化搭建，如果不清楚如何配置可以直接回车 安装依赖1npm install commander download-git-repo chalk inquirer ora --save 构建结构创建bin和commands文件夹以及配置文件templates.json。bin文件夹为可执行命令入口目录，commands则负责编写一些命令交互 最终目录结构123456- al-block-cli| - bin| - commands| - node_modules| - package.json| - templates.json 编写代码配置文件输入默认需要的配置，如这里需要github的仓库地址和命令行的名称 123456&#123; \"init\": &#123; \"name\": \"init\", \"path\": \"Alisdon/al-block-template\" &#125;&#125; 入口文件新建al-block-cli文件，并在其第一行加入 1#! /usr/bin/env node 此行为了防止操作系统用户没有将node装在默认的/usr/bin路径里。当系统看到这一行的时候，首先会到env设置里查找node的安装路径，再调用对应路径下的解释器程序完成操作。 123456789101112131415161718192021222324#!/usr/bin/env nodeprocess.env.NODE_PATH = __dirname + '/../node_modules/';const program = require('commander');program .version(require('../package').version);program .usage('&lt;command&gt;');program.command('init') .description('create a new project') .alias('i') .action(() =&gt; &#123; require('../commands/init') &#125;);program.parse(process.argv);if(!program.args.length)&#123; program.help()&#125; 命令交互新建init.js文件表示命令init 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192const &#123; prompt &#125; = require('inquirer');const program = require('commander');const chalk = require('chalk');const download = require('download-git-repo');const ora = require('ora');const fs = require('fs');const option = program.parse(process.argv).args[0];const question = [ &#123; type: 'input', name: 'name', message: 'Project name', default: typeof option === 'string' ? option : 'al-block-template', filter (val) &#123; return val.trim() &#125;, validate (val) &#123; const validate = (val.trim().split(\" \")).length === 1; return validate || 'Project name is not allowed to have spaces '; &#125;, transformer (val) &#123; return val; &#125; &#125;, &#123; type: 'input', name: 'description', message: 'Project description', default: 'Vue project', validate () &#123; return true; &#125;, transformer(val) &#123; return val; &#125; &#125;, &#123; type: 'input', name: 'author', message: 'Author', default: '', validate () &#123; return true; &#125;, transformer(val) &#123; return val; &#125; &#125;];module.exports = prompt(question).then((&#123;name, description, author&#125;) =&gt; &#123; const gitPlace = require('../templates').init.path; const projectName = name; const spinner = ora('Downloading please wait...'); spinner.start(); download(`$&#123;gitPlace&#125;`, `./$&#123;projectName&#125;`, (err) =&gt; &#123; if (err) &#123; console.log(chalk.red(err)); process.exit() &#125; fs.readFile(`./$&#123;projectName&#125;/package.json`, 'utf8', function (err, data) &#123; if(err) &#123; spinner.stop(); console.error(err); return; &#125; const packageJson = JSON.parse(data); packageJson.name = name; packageJson.description = description; packageJson.author = author; fs.writeFile(`./$&#123;projectName&#125;/package.json`, JSON.stringify(packageJson, null, 2), 'utf8', function (err) &#123; if(err) &#123; spinner.stop(); console.error(err); &#125; else &#123; spinner.stop(); console.log(chalk.green('project init successfully!')) console.log(` $&#123;chalk.yellow(`cd $&#123;name&#125;`)&#125; $&#123;chalk.yellow('npm install')&#125; $&#123;chalk.yellow('npm run dev')&#125; `); &#125; &#125;); &#125;); &#125;)&#125;); 测试发布测试至此，一个简单的脚手架（壳）就已经完成了，为了查看在编写过程中是否出错，我们现在本地进行测试 1node bin/al-block-cli 如果没有报错，出现了熟悉的命令行，那就说明成功了 发布发布之前我们需要做个小调整，观察其他脚手架工具他们都是以自己独特的key值进行搭建，对此我们可以在package.json里面配置bin对象 123\"bin\": &#123; \"al-block-cli\": \"bin/al-block-cli\"&#125; 这里需要注意bin/后面的al-block-cli,这个路径是由入口文件的路径确定，如果你是建的al-block-cli.js则此处应该配置bin/al-block-cli.js，本篇是创建的没有后缀名的文件 修改后生成的最终package.json 1234567891011121314151617181920212223242526&#123; \"name\": \"al-block-cli\", \"version\": \"1.0.0\", \"description\": \"al-block-cli\", \"keywords\": [ \"vue\", \"al-block\", \"al-block-cli\" ], \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"bin\": &#123; \"al-block-cli\": \"bin/al-block-cli\" &#125;, \"preferGlobal\": true, \"author\": \"Alisdon [920124512@qq.com]\", \"license\": \"MIT\", \"dependencies\": &#123; \"chalk\": \"^2.4.1\", \"commander\": \"^2.19.0\", \"download-git-repo\": \"^1.1.0\", \"inquirer\": \"^6.2.1\", \"ora\": \"^3.0.0\" &#125;&#125; 对比文件内容，如果没有问题我们就开始发布了 12npm loginnpm publish","categories":[{"name":"node","slug":"node","permalink":"https://alisdon.github.com/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://alisdon.github.com/tags/node/"}]},{"title":"用于mmzsblog网站博客开发","slug":"mmzsblog","date":"2018-11-20T13:07:16.000Z","updated":"2018-11-23T11:11:39.575Z","comments":true,"path":"mmzs/mmzsblog/","link":"","permalink":"https://alisdon.github.com/mmzs/mmzsblog/","excerpt":"","text":"前提条件提醒以下代码均在系统命令行(非node环境下的命令行)下完成。 cmd打开window系统命令行 直接在mac系统中打开终端 安装nodeJs前往 node官方下载地址下载对应版本进行安装 检测安装状态1$ node -v 出现版本信息则表示安装成功 安装git前往 git官方下载地址下载对应版本进行安装 检测安装状态1$ git --version 出现版本信息则表示安装成功 安装hexo1$ npm install -g hexo-cli 此步骤需要将nodejs安装成功后才可进行，否则将报npm命令不存在的错误 检测安装状态1$ hexo version 出现版本信息则表示安装成功 克隆代码克隆框架代码1$ git clone git@www.mmzsblog.cn:/mmzsblog/blog.git 此步骤需要将git安装成功后才可进行，否则将报git命令不存在的错误。后续在新增文章之前需要先更新框架代码。拉取成功后默认文件夹名称为blog，本篇文章以blog为文件夹名称举例 克隆主题代码12$ cd blog$ git clone git@www.mmzsblog.cn:/mmzsblog/theme.git themes/pure 此步骤需要将git安装成功后才可进行，否则将报git命令不存在的错误，由于框架代码中主题代码不能提交成功，所以将其分开获取。此代码只需要拉取一次，后续新增文章之前可不再更新 安装依赖1$ npm install 执行成功上述操作将出现图中目录文件 开始创建新建文章创建文章之前先更新仓库代码，然后再创建一篇新文章 12$ git pull$ hexo new 你的文章名称 打开当前文件夹下的source/_post目录，找到新建的文件（一般是根据上方新建的文章名称作为文件名称）进行编写 静态图片的处理 放到source/images文件中，在文章中需要进行![](/images/xxx.jpg)的引入 直接放到和文章名称相同的文件夹中，在文章中需要进行![](./xxx.png)的引入 预览文章1$ hexo server 简写 hexo s 打开浏览器输入http://localhost:4000进行访问。如果出现白板且控制台出现了index.html相关的问题则是由于没有获取主题导致的，需要前往克隆主题文件 发布文章由于mmzsblog是通过github进行重定向，所以将不做清理静态文件的操作，避免提交后需要重新设置的重复操作 打包编译12$ git pull$ hexo generate 简写 hexo g 发布提交1$ hexo deploy 简写 hexo d 如果出现以上提示则说明提交成功，隔几分钟后刷新https://blog.mmzsblog.cn即可查看刚刚新增的文章 提交代码提交框架代码，避免多人开发时不同步的问题 1234$ git status$ git add .$ git commit -m '新增一篇文章'$ git push","categories":[{"name":"mmzs","slug":"mmzs","permalink":"https://alisdon.github.com/categories/mmzs/"}],"tags":[{"name":"mmzs","slug":"mmzs","permalink":"https://alisdon.github.com/tags/mmzs/"}]},{"title":"mac下安装nginx","slug":"mac 下安装nginx","date":"2018-10-19T06:14:37.000Z","updated":"2018-11-23T16:01:56.878Z","comments":true,"path":"server/mac 下安装nginx/","link":"","permalink":"https://alisdon.github.com/server/mac 下安装nginx/","excerpt":"","text":"初识nginx相信大多数同学已经听说了nginx这个东东，会不会很多同学和我一样一开始接触nginx的时候不知道它是什么？它能干什么？如果需要启服务，完全可以用node，为什么还需要使用nginx？ 对以上问题，我先引用一下官方对nginx的介绍 “Nginx是一款轻量级的HTTP服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的IO性能，时常用于服务端的反向代理和负载均衡。” nginx的应用场景 http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 nginx的优点nginx的优点在应用场景中已有体现，比如上面提到的反向代理，负载均衡功能。除此之外还有以下优势 支持海量高并发：采用IO多路复用epoll。官方测试Nginx能够支持5万并发链接，实际生产环境中可以支撑2-4万并发连接数。 内存消耗少：在主流的服务器中Nginx目前是内存消耗最小的。 配置文件简单：网络和程序配置通俗易懂，即使非专业运维也能看懂。 支持热部署：这对于我们前端的同学来说，使用惯webpack的热更新，对热更新的支持，无疑是吸引了一大波同学（我就算其中一个，啊哈哈） 安装nginx前面铺垫了这么多，现在终于进入主题了。本教程是使用homebrew进行安装，未安装brew的同学请自行安装 brew install nginx 配置文件地址安装成功后需要对配置文件进行个性化定制，本教程提供大部分时间需要修改的配置，配置文件在如下地址处 /usr/local/etc/nginx/nginx.conf 默认根目录是否想知道网址访问的哪份文件呢？来，我们一起打开它 /usr/local/var/www/ 启动重启关闭成功安装后，我们肯定就是来使用nginx了，你可使用 nginx 直接启动或者使用 nginx -s reload|reopen|stop|quit 重新加载配置|重启|快速停止|安全关闭 启动成功后，我们就只需要在浏览器中访问服务（地址）就好了 http://localhost:8080 自定义配置修改访问端口默认8080被占用了？或者你看8080端口不爽？来，我们一起灭了它 修改默认根目录修改完8080，你是否觉得用默认的网站根目录很难找？是不是想换成自己熟悉的目录呢？ tips: 配置文件里location / 里面的root,将yourname换成你电脑的用户名 异常处理Permission问题这种问题都是没有权限引起的，执行代码前加上sudo即可 Forbidden修改了默认的网站根目录，出现问题时避免不了的。但是怎么办呢？这种问题一般是没有找到对应的文件，要不就是权限的问题 查看目录下是否存在index.html或者index.htm 修改配置文件第一行为 user root owner; 然后重启 File not find同上 Forbidden 的解决方案 卸载nginx好了，最后，如果你还是觉得nginx用起来不爽，更喜欢node，Apache什么的，勇敢的卸载它吧 brew uninstall nginx","categories":[{"name":"server","slug":"server","permalink":"https://alisdon.github.com/categories/server/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://alisdon.github.com/tags/nginx/"}]},{"title":"hexo","slug":"hexo","date":"2018-07-27T16:12:50.132Z","updated":"2018-11-21T08:38:45.663Z","comments":true,"path":"hexo/hexo/","link":"","permalink":"https://alisdon.github.com/hexo/hexo/","excerpt":"","text":"安装hexonpm install -g hexo-cli 初始化项目hexo init &lt;folder&gt; cd &lt;folder&gt; npm install`` 启动项目hexo server 更换主题选择喜欢的主题并根据选择的主题进行更换，并将_config.yml中的theme主题替换成在文件夹theme中的文件名称, 添加主题中需要的图片等素材 hexo快捷命令及快速发布hexo clean 清理静态化内容 hexo generate 简化 hexo g hexo deploy 简化 hexo d","categories":[{"name":"hexo","slug":"hexo","permalink":"https://alisdon.github.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://alisdon.github.com/tags/hexo/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-07-27T16:12:50.110Z","updated":"2018-11-21T08:38:57.148Z","comments":true,"path":"hexo/hello-world/","link":"","permalink":"https://alisdon.github.com/hexo/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate (hexo g) More info: Generating Deploy to remote sites1$ hexo deploy (hexo d) More info: Deployment","categories":[{"name":"hexo","slug":"hexo","permalink":"https://alisdon.github.com/categories/hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://alisdon.github.com/tags/hexo/"}]},{"title":"linux下实现无密操作git","slug":"linux下实现无密操作git","date":"2018-07-24T08:44:46.000Z","updated":"2018-11-23T16:03:09.200Z","comments":true,"path":"server/linux下实现无密操作git/","link":"","permalink":"https://alisdon.github.com/server/linux下实现无密操作git/","excerpt":"","text":"linux服务端配置linux安装git yum install -y git 创建用户git groupadd git adduser git -g git 配置linux权限问题及创建authorized_keys文件 cd /home/git mkdir .ssh chmod 700 .ssh touch .ssh/authorized_keys chmod 600 .ssh/authorized_keys cd /home chown -R git:git git Tips:后续的git clone如果需要密码，很有可能是git用户没有访问authorized_keys文件的权限 创建git仓库文件夹 cd /home mkdir gitTest chown git:git gitTest //赋予git用户权限 初始化git仓库 cd gitTest git init --bare gitTest.git 把仓库所属用户改为git chown -R git:git gitTest.git 创建post-receive文件（若不使用git自启动属性可不操作） vim ~/gitTest.git/hooks/post-receive post-receive文件内容（若不使用git自启动属性可不操作） #！/bin/sh git --work-tree=/usr/share/nginx/html/blog --git-dir=/home/gitTest/gitTest.git checkout -f 设置权限（若不使用git自启动属性可不操作） chmod +x ~/gitTest.git/hooks/post-receive 创建客户端口令ssh-keygen -t rsa -C &apos;你的邮箱&apos; 设置免密登录口令将id_rsa.pub中的内容写到服务器的authorized_keys文件中。 cat id_rsa.pub &gt;&gt; authorized_keys 请求git仓库git clone git@ip:/home/gitTest/gitTest.git","categories":[{"name":"server","slug":"server","permalink":"https://alisdon.github.com/categories/server/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://alisdon.github.com/tags/linux/"}]}]}