{"meta":{"title":"Alisdon Blog","subtitle":"Time is the most precious wealth of all wealth","description":"wlf的博客","author":"Alisdon","url":"https://alisdon.github.com"},"pages":[{"title":"关于","date":"2022-08-03T14:15:08.946Z","updated":"2018-11-21T02:34:17.089Z","comments":false,"path":"about/index.html","permalink":"https://alisdon.github.com/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"分类","date":"2022-08-03T14:15:08.964Z","updated":"2018-11-21T02:34:17.089Z","comments":false,"path":"categories/index.html","permalink":"https://alisdon.github.com/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-08-03T14:15:08.958Z","updated":"2018-11-21T02:34:17.089Z","comments":true,"path":"links/index.html","permalink":"https://alisdon.github.com/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-08-03T14:15:08.957Z","updated":"2018-11-21T02:34:17.090Z","comments":false,"path":"tags/index.html","permalink":"https://alisdon.github.com/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2022-08-03T14:15:07.703Z","updated":"2018-11-21T02:34:17.090Z","comments":false,"path":"repository/index.html","permalink":"https://alisdon.github.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"带你走进 Typescript 泛型","slug":"带你走进 typescript 泛型","date":"2023-03-01T16:00:00.000Z","updated":"2023-03-02T10:24:39.107Z","comments":true,"path":"Typescript/带你走进 typescript 泛型/","link":"","permalink":"https://alisdon.github.com/Typescript/带你走进 typescript 泛型/","excerpt":"","text":"Typescript 是一门静态类型、弱类型的语言。静态是指在编译阶段进行类型检查， 所以要求我们需要在开发期间就对数据类型给出类型申明。弱类型是由于 Javascript 属于一门弱类型语言， 而 Typescript 完全兼容 Javascript，不会修改 JavaScript 运行时的特性，同时两者都存在隐式类型转换（比如 ‘1’ + 1），所以它们都是弱类型语言。 引用一下官方的解释来开始这一篇的主角 —- 泛型 软件工程中，我们不仅要创建一致的定义良好的API，同时也要考虑可重用性。 组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型，这在创建大型系统时为你提供了十分灵活的功能。 在像C#和Java这样的语言中，可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。 这样用户就可以以自己的数据类型来使用组件。 虽然上面理解起来还是比较晦涩。但是也看出泛型所要解决的问题。正如前面我们说到的，Typescript 属于一门静态类型语言，那么我们在开发阶段需要给出一种既满足良好的API又满足未来复用的类型，这种类型可以是一个占位，只是在未来需要用到的时候再将其替换。所以在我看来 泛型是泛指某种类型，是一种在定义接口、函数或类的时候，不预先指定具体的类型，而在使用的时候再指定具体类型的解决方案。 先来看看我们平常看到的泛型 “KTV”: 12345interface Identities&lt;K, T, V&gt; &#123; key: K, type: T, value: V&#125; 在平时我们阅读 Typescript 项目时，肯定避免不了遇见的这种写法，对于我们写惯了 Javascript 语言来说，在 Javascript 里面写了 HTML 标签， 如果没有接触过 JSX 语法， 会不会让你感觉这就是传说中的 JSX？ 其实，你看到这个就说明这个地方用上了 Typescript 的泛型，而这里的“KTV”也不是固定的写法，更多的， 这其实只是一种自我约束，或者说是行业内达成的一种共识。如果换成其他的字母代替 T ，在可读性上可能会弱一些，但是并不会影响程序的正常运行。通常情况下，T，K，V，E 是这样约定的： T (type) 表示具体的一个类型 K (key) 代表接口类型中的Key V (value) 代表接口类型中的Value E (element) 代表 Element 泛型接口泛型接口其实和普通的接口类型相差不大，只是在接口类型名称后面跟上了我们的泛型标志，比如： 1234567interface UserInfo &#123; hobby: &apos;dance&apos; | &apos;swim&apos;;&#125;interface UserInfo&lt;T&gt; &#123; hobby: T;&#125; 那么用上了泛型能解决什么问题呢？我们来看这个案例： 我们有一位同学叫张三，他的爱好是跳舞，我们另外一位同学李四的爱好是游泳 现在我们不使用泛型， 直接用上面的 UserInfo 接口也不会报错，能够正常运行。 123456interface UserInfo &#123; hobby: &apos;dance&apos; | &apos;swim&apos;;&#125;const zhangsan: UserInfo = &#123; hobby: &apos;dance&apos; &#125;;const lisi: UserInfo = &#123; hobby: &apos;swim&apos; &#125;; 但是这样会出现一个问题，在我们使用这个变量时，获取张三这位同学的爱好时， 是可以取到 swim 爱好的，比如代码中的if判断： 12345678910interface UserInfo &#123; hobby: &apos;dance&apos; | &apos;swim&apos;;&#125;const zhangsan: UserInfo = &#123; hobby: &apos;dance&apos; &#125;;const lisi: UserInfo = &#123; hobby: &apos;swim&apos; &#125;;if (zhangsan.hobby === &apos;swim&apos;) &#123; console.log(&apos;zhangsan is like swim&apos;);&#125; 很显然我们张三同学没有 swim 这个爱好，这个判断是多余的，那么我们如何去规避这个问题呢？这个时候泛型就起到了作用， 在我们一开始的时候不去指定具体的类型，只是在使用的时候再指定具体类型，最后的使用方式如下： 12345678910interface UserInfo&lt;T&gt; &#123; hobby: T;&#125;const zhangsan: UserInfo&lt;'dance'&gt; = &#123; hobby: 'dance' &#125;;const lisi: UserInfo&lt;'swim'&gt; = &#123; hobby: 'swim' &#125;;if (zhangsan.hobby === 'swim') &#123; console.log('zhangsan is like swim');&#125; 至此可能看不出有什么问题，那是为什么呢？ 是否泛型其实是没用的呢？ 其实不是， 我们回顾一下Typescript 是一门静态类型、弱类型的语言， 所以说这会在编译阶段进行类型检查，再反馈到开发阶段，我们回到编辑器界面可以看到如下： 这个红色的波浪线提醒了我们 “这个判断条件将恒为 false“， 所以这可以让我们在开发阶段避免一些错误。 泛型函数泛型函数和普通函数的区别就在于泛型函数在函数名称后面加入了待指定类型的标志。同时泛型函数也是可以解决类型不灵活带来错误推导的问题。 123456789101112131415interface UserInfo&lt;T&gt; &#123; hobby: T;&#125;// 普通函数function getUserInfo(user: UserInfo&lt;&apos;dance&apos;&gt;): UserInfo&lt;&apos;dance&apos;&gt; &#123; return user;&#125;getUserInfo(user);// 泛型函数function getUserInfo&lt;T&gt;(user: UserInfo&lt;T&gt;): UserInfo&lt;T&gt; &#123; return user;&#125;getUserInfo&lt;&apos;dance&apos;&gt;(user); 普通函数面临的问题和上面泛型接口是一样的，在获取李四同学信息时， 由于李四的爱好中没有跳舞，所以根据 Typescript 的类型推断，将出现一条红色的波浪线。 那我们用泛型函数来实现就能够解决这个问题 123456789101112interface UserInfo&lt;T&gt; &#123; hobby: T;&#125;const zhangsan: UserInfo&lt;'dance'&gt; = &#123; hobby: 'dance' &#125;;const lisi: UserInfo&lt;'swim'&gt; = &#123; hobby: 'swim' &#125;;function getUserInfo&lt;T&gt;(user: UserInfo&lt;T&gt;): UserInfo&lt;T&gt; &#123; return user;&#125;getUserInfo&lt;'dance'&gt;(zhangsan);getUserInfo&lt;'swim'&gt;(lisi); 如果我们结合接口定义函数的方式来实现， 上面泛型函数的实现等价于 12345678910interface UserInfo&lt;T&gt; &#123; hobby: T;&#125;const zhangsan: UserInfo&lt;&apos;dance&apos;&gt; = &#123; hobby: &apos;dance&apos; &#125;;const lisi: UserInfo&lt;&apos;swim&apos;&gt; = &#123; hobby: &apos;swim&apos; &#125;;const getUserInfo: GetUserInfo = (user) =&gt; user;getUserInfo&lt;&apos;dance&apos;&gt;(zhangsan);getUserInfo&lt;&apos;swim&apos;&gt;(lisi); 泛型函数在平时我们也会使用很多， 比如React.Component&lt;any, any&gt; 泛型类泛型类看上去与泛型接口和泛型函数差不多。 泛型类使用（ &lt;&gt;）括起泛型类型，跟在类名后面。 123456789101112class Person&lt;T&gt; &#123; hobby: T; constructor(hobby: T) &#123; this.hobby = hobby; &#125; speak: () =&gt; string = () =&gt; `I like $&#123;this.hobby&#125;`;&#125;const zhangsan = new Person&lt;&apos;dance&apos;&gt;(&apos;dance&apos;);const lisi = new Person&lt;&apos;swim&apos;&gt;(&apos;swim&apos;);console.log(zhangsan.speak()); // &apos;I like dance&apos;;console.log(lisi.speak()); // &apos;I like swim&apos;; 但值得注意的是，类有两部分：静态部分和实例部分。 泛型类指的是实例部分的类型，所以类的静态属性不能使用这个泛型类型。 12345678class Person&lt;T&gt; &#123; hobby: T; constructor(hobby: T) &#123; this.hobby = hobby; &#125; speak: () =&gt; string = () =&gt; `I like $&#123;this.hobby&#125;`; static getHobby: () =&gt; T;&#125; 比如上面这种写法是不允许的 泛型类我们平时也使用挺多的， 比如new Promise&lt;string&gt;、new Map&lt;string, string&gt;()等等，这些都是通过泛型类实现的。 泛型约束相信大家在看泛型类的时候已经发现了一个问题，如果我们待制定的变量T没有约束的话， 我们可以传任意的值进去，比如出现这样的代码 12345678910class Person&lt;T&gt; &#123; hobby: T; constructor(hobby: T) &#123; this.hobby = hobby; &#125; speak: () =&gt; string = () =&gt; `I like $&#123;this.hobby&#125;`;&#125;const xiaohua = new Person&lt;&apos;apple&apos;&gt;(&apos;apple&apos;);console.log(xiaohua.speak()); // &apos;I like apple&apos;; 虽然这能够通过我们的编译， 但这已经不符合我们的需求了，apple 肯定不是一种hobby。对于此问题Typescript给的解决方案就是泛型约束，顾名思义就是将泛型约束起来， 让其只能是某个或某种类型。改造之后如下: 123456789type Hobby = &apos;dance&apos; | &apos;swim&apos;;class Person&lt;T extends Hobby&gt; &#123; hobby: T; constructor(hobby: T) &#123; this.hobby = hobby; &#125; speak: () =&gt; string = () =&gt; `I like $&#123;this.hobby&#125;`;&#125;const zhangsan = new Person&lt;&apos;apple&apos;&gt;(&apos;apple&apos;); 如斯，我们在编辑器中将出现红色波浪线提示我们 apple 不满足 Hobby 类型的。 通过这种方式，我们就能够对泛型进行一定的约束，能够更好的控制我们输入的类型，确保在使用时的正确性。 泛型参数的默认类型在 typescript 2.3 版本中新增了泛型参数默认值特性，其用法和Javascript中的默认参数一致 12345678910111213interface UserInfo&lt;T = 'dance'&gt; &#123; hobby: T&#125;function getUserInfo&lt;T = 'dance'&gt;(user: UserInfo&lt;T&gt;): UserInfo&lt;T&gt; &#123; return user;&#125;class Person&lt;T = 'dance'&gt; &#123;&#125;const zhangsan = &#123;&#125; as UserInfo;const zhangsan1 = getUserInfo(&#123;&#125; as UserInfo);const zhangsan2 = new Person(); 通过上面的定义，我们能够看到，尽管我们在使用的时候没有去定义具体的类型， 但是当鼠标滑上去的时候， typescript还是帮我们推导出了默认的 dance 类型。 工具类型 工具类型参考链接： https://juejin.cn/post/6844903981521567752 Partial将构造类型T的所有属性设置为可选。 123456789101112131415// 内部实现原理type Partial&lt;T&gt; = &#123; [K in keyof T]?: T[K]&#125;// 使用案例interface UserInfo &#123; hobby: string&#125;type PUserInfo = Partial&lt;UserInfo&gt;// PUserInfo 等价于type PUserInfo = &#123; hobby?: string&#125; Require将类型T所有属性设为require。所有没有带问号?的属性都属于require ， 此工具主要是为了减去可选标识。 123456789101112131415// 内部实现原理type Require&lt;T&gt; = &#123; [P in keyof T]-?: T[P];&#125;// 使用案例interface UserInfo &#123; hobby?: string&#125;type RUserInfo = Require&lt;UserInfo&gt;// RUserInfo 等价于type RUserInfo = &#123; hobby: string&#125; Record&lt;K, V&gt;构造一个类型，其属性名为K，值为V 123456789101112// 内部实现原理type Record&lt;K extends keyof any, V&gt; = &#123; [P in K]: V; &#125;// 使用案例type RUserInfo = Record&lt;&apos;hobby&apos;, string&gt;// RUserInfo 等价于type RUserInfo = &#123; hobby: string&#125; Pick&lt;T, K&gt;从类型T中挑选部分属性K来构造新的类型 12345678910111213141516// 内部实现原理type Pick&lt;T, K extends keyof T&gt; = &#123; [P in K]: T[P];&#125;// 使用案例interface UserInfo &#123; hobby: string; speak: () =&gt; string&#125;type PUserInfo = Pick&lt;UserInfo, &apos;hobby&apos;&gt;// PUserInfo 等价于type PUserInfo = &#123; hobby: string&#125; Exclude&lt;T, U&gt;从类型T中，剔除所有能赋值给U的属性 123456789// 内部实现原理type Exclude&lt;T, U&gt; = T extends U ? never : T;// 使用案例type Hobby = &apos;dance&apos; | &apos;swim&apos;;type EHobby = Exclude&lt;&apos;dance&apos; | (() =&gt; void), Hobby&gt;;// EHobby 等价于type EHobby = () =&gt; void Extract&lt;T, U&gt;从类型T中提取所有可以赋值给U的类型 123456789// 内部实现原理type Extract&lt;T, U&gt; = T extends U ? T : never;// 使用案例type Hobby = &apos;dance&apos; | &apos;swim&apos;;type EHobby = Extract&lt;&apos;dance&apos; | (() =&gt; void), Hobby&gt;;// EHobby 等价于type EHobby = &apos;dance&apos; Omit&lt;T, K&gt;从类型T中剔除所有能赋值给K的属性 1234567891011121314// 内部实现原理type Omit&lt;T, K extends keyof T&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;// 使用案例interface UserInfo &#123; hobby: string; speak: () =&gt; string&#125;type OUserInfo = Omit&lt;UserInfo, &apos;speak&apos;&gt;// OUserInfo 等价于type OUserInfo = &#123; hobby: string&#125; NonNullable从T中剔除null和undefined 123456789// 内部实现原理type NonNullable&lt;T&gt; = T extends undefined | null ? never : T;// 使用案例type Hobby = &apos;dance&apos; | null | undefined;type NHobby = NonNullable&lt;Hobby&gt;;// NHobby 等价于type NHobby = &apos;dance&apos; ReturnType由函数类型T的返回值类型构造一个类型 123456789// 内部实现原理type ReturnType&lt;T extends (...arg: any) =&gt; any&gt; = T extends (...arg:any) =&gt; infer R ? R : any;// 使用案例type Speak = () =&gt; stringtype RSpeak = ReturnType&lt;Speak&gt;;// RSpeak 等价于type RSpeak = string; infer R 表示待推断的函数返回值。如果T能够赋值给(...arg:any) =&gt; infer R则结果是R，否则是any Readonly将T中所有属性设为只读 1234567891011121314151617// 内部实现原理type Readonly&lt;T&gt; = &#123; readonly [K in keyof T]: T[K];&#125;// 使用案例interface UserInfo &#123; hobby: string; speak: () =&gt; string&#125;type RUserInfo = Readonly&lt;UserInfo&gt;;// RUserInfo 等价于type RUserInfo = &#123; readonly hobby: string; readonly speak: () =&gt; string&#125;; 总结泛型在 Typescript 中有着至关重要的份量，甚至有人调侃学会了泛型才算是真正进入 Typescript 开发。在我看来所谓泛型终究还是那句话：泛型是泛指某种类型，是一种在定义接口、函数或类的时候，不预先指定具体的类型，而在使用的时候再指定具体类型的解决方案。 BTW, 留下一个小作业 1234567891011121314&gt; interface UserInfo &#123;&gt; hobby: string;&gt; speak: () =&gt; string&gt; &#125;&gt; &gt; type SetPartial&lt;T, K&gt; = ??;&gt; type SUserInfo = SetPartial&lt;UserInfo, &apos;speak&apos;&gt;;&gt; &gt; // SUserInfo 等价于&gt; type SUserInfo = &#123;&gt; hobby: string;&gt; speak?: () =&gt; string&gt; &#125;&gt; 实现 SetPartial&lt;T, K&gt; 将构造类型 T 中的 K 设置为可选。","categories":[{"name":"Typescript","slug":"Typescript","permalink":"https://alisdon.github.com/categories/Typescript/"}],"tags":[{"name":"Typescript","slug":"Typescript","permalink":"https://alisdon.github.com/tags/Typescript/"}]},{"title":"关于代码质量的一些思考","slug":"关于代码质量的一些思考","date":"2022-11-02T08:51:01.923Z","updated":"2022-11-10T03:11:04.764Z","comments":true,"path":"其他/关于代码质量的一些思考/","link":"","permalink":"https://alisdon.github.com/其他/关于代码质量的一些思考/","excerpt":"","text":"最近一直在思考一个问题, 每次做代码 code review 时, 在内心都会有一个纠结点 - 这段阅读起来十分头痛的代码实现了业务并且平稳运行了, 那这块的代码到底算不算是一段合格的代码? 经过一段时间的反复博弈, 我给出了肯定的答案, 任何的程序都是为了准确无误的运行. 从这一点来说, 这是一段合格的代码, 但是那段代码阅读起来又是如此的难以理解更不用说上手调整, 所以这算不上是一段好质量代码。 为什么我们要写一些质量好的代码? 场景: 接到一个开发任务 噼里啪啦开发完成 一周后这个地方可以优化一下, 那个地方存在bug需要修复 一个月后这写的什么东西, 看不懂啊 又一个月后无力维护, 开始甩锅 针对这一个场景, 可能有些夸张, 毕竟拿了老板的钱就需要帮老板排忧解难, 怎么能甩锅呢? 可以拿《世界很大, 我想去看看》的理由和老板‘协商’嘛! 而这种情况其实我是亲身经历过的, 当然我说的是前面那部分, 到看不懂自己写的代码哪儿截止。但是不难看出, 代码不仅仅只是为了运行起来, 还需要考虑后期的维护。 场景: 接到一个功能迭代任务 打开并开始阅读第一个函数代码 找到了需要改动的代码, 开始输入了第一行代码 又删除了输入的代码, 并进入了另外一个函数 又开始输入代码, 输入一半, 又删除了输入代码 回到了最初改动代码的位置, 将代码做了还原 打开新的窗口继续查看 我们在修改代码的时候, 首先需要做的就是阅读理解已有代码(废话), 当遇到一段难以理解维护的代码时, 无疑会增加你的阅读时间, 这样你的投入时间越多, 性价比就越低。 而往往在多人合作开发中, 阅读已有代码这是一个不可避免的存在, 所以我们更加需要去写一些高质量的代码让我们的代码变得可读、易读。 什么样的代码才算是好质量代码?通过上面的两个场景, 我们已经对高质量代码的重要性有了一个共同的认识, 那么什么样的代码才算是高质量代码呢? 在软件质量评价标准中对影响软件质量的定义提到了以下特性 可理解性(‘我能理解它吗?’) 可维护性(‘我能修复它吗?’) 灵活性(‘我能改变它吗?’) 可测试性(‘我能测试它吗?’) 可移植性(‘我能在另外一台机器上运行它吗?’) 可重用性(‘我能再用它的某些部分吗?’) 互运行性(‘我能把它和另外一个系统结合吗?’) 正确性(‘它按照我的需求工作吗?’) 健壮性(‘对意外环境它能适当适应吗?’) 效率(‘完成预定功能时它需要的计算机资源多吗?’) 完整性(‘它是安全的吗?’) 可用性(‘我能使用它吗?’) 风险性(‘能按预定计划完成它吗?’) 同时在《代码整洁之道》中关于什么是整洁代码一段中, 作者询问了一些非常知名且经验丰富的程序员 C++ 语言发明者 - Bjarne Stroustrup 我喜欢优雅和高效的代码。代码逻辑应该直接了当，叫缺陷难以隐藏；尽量减少依赖关系，使之便于维护；依据某种分层战略完善错误处理代码。性能调制最优，省的引诱别人做没规矩的优化，搞出一堆混乱来。整洁的代码只做好一件事。 《面向对象设计与分析》作者 - Grady Booch 简洁的代码简单直接。简洁的代码如同优美的散文。简洁的代码从不隐藏设计者的意图，充满了干净利落的抽象和直接了当的控制语句。 OTI公司创始人、Eclipse 战略教父 - Dave Thomas 整洁的代码应可由作者之外的开发者阅读和增补。它应有单元测试和验收测试。它使用有意义的命名。它只提供一种而非多种做一件事的途径。它只有尽量少的依赖关系，而且要明确地定义和提供清晰、尽量少的API。代码应通过其字面表达含义，因为不同的语言导致并非所有必须信息均可通过代码自身清晰表达。 《修改代码的艺术》作者 - Michael Feathers 我可以列出我留意到的简洁代码的所有优点，但其中有一条是根本性的。简洁的代码总是看起来像是某位特别在意它的人写的。几乎没有改进的余地，代码作者几乎什么都想到了，如果你企图改进他，总会回到原点，赞叹某人留给你的代码–全心投入的某人留给你的代码。 《极限编程实施》、《C#极限编程探险》作者 - Ron Jeffries 简单代码, 依其重要顺序: 能通过所有测试 没有重复代码 体现系统中的全部设计理念 包括尽量少的实体, 比如类、方法、函数等 减少重复代码, 提高表达力, 提早构建简单抽象。 Wiki 发明者 - Ward Cunningham 如果每个例程都让你感到深合已意，那就是整洁代码。如果代码让编程语言看起来像是专为解决那个问题而存在，就可以称之为漂亮的代码。 怎样去写好质量代码? 此篇主要是提出一些相关的思考, 后续将针对以下部分做详细总结。 制定统一的编码规范众所周知, 一个团队中的开发水平很能保持高度统一, 所以这个是我们需要借助一些工具来制定项目的编码规范。目前(2022年)是用较为广泛的为 eslint + prettier 组合, 针对编码规范, 我觉得应该从这些方面出发 统一技术栈: 项目中切忌出现不同的技术栈风格(如有人使用less, 也有人使用sass)。 统一代码风格: 如统一使用空格2格还是tab 4格需要保持一致, 否则切换页面后会产生不是同一个项目的错觉。 语义化命名: 较好的命名可以让阅读者有信息继续阅读下去, 这不是夸张说法, 试想看到一个名为 q和queryUserInfo的函数, 谁更能让你愿意阅读下去呢? 写好注释: 这对阅读代码具有重要的参考意义。但这里所说的注释应避免无意义注释、魔法注释。 使用一些实现技巧 各语言的使用技巧各不相同, 唯有不断积累总结才有效果, 下方以 javascript 为例 巧用数组 some、every、include find、findIndex、indexOf reduce 巧用运算符 +、-、!、~ &amp;、&amp;&amp;、|、|| &gt;&gt;、&lt;&lt; 其他 Object.assign、Object.keys、Object.values、Object.entries performance.now URLSearchParams 展开操作符 遵循设计原则 单一职责: 程序功能要单一明确 开闭原则: 尽量减少原有代码的修改 里式替换原则: 子类能够覆盖父类 接口隔离原则: 保持接口的单一独立(JS中较少) 依赖倒置原则: 不依赖具体实现 KISS原则: 尽量保持代码简单 YAGNI原则: 避免过度设计, 但需要考虑扩展性 DRY原则: 避免重复性代码 LOD原则: 最小知识原则 合理使用设计模式 参考链接: https://refactoringguru.cn/design-patterns/catalog TIPS: 需自寻🍇, 另链接文章中出现的政治言论与本人无关, 一切以学习为主 工厂方法: 父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型 抽象工厂: 创建一系列相关的对象， 而无需指定其具体类 生成器模式: 该模式允许你使用相同的创建代码生成不同类型和形式的对象。 原型模式: 能够复制已有对象， 而又无需使代码依赖它们所属的类。 单例模式: 能够保证一个类只有一个实例， 并提供一个访问该实例的全局节点。 适配器模式: 能使接口不兼容的对象能够相互合作。 桥接模式: 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。 组合模式: 可使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。 装饰模式: 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。 外观模式: 能为程序库、 框架或其他复杂类提供一个简单的接口。 享元模式: 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。 代理模式: 能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。 责任链模式: 允许你将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。 命令模式: 可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。 迭代器模式: 能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。 中介模式: 能让你减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。 备忘录模式: 允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。 观察者模式: 允许定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。 状态模式: 能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。 策略模式: 能定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。 模版模式: 在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。 访问者模式: 能将算法与其所作用的对象隔离开来。 结语我相信作为程序猿, 追求好的代码质量是我们一生的目标和使命。在我看来, 我们需要需要做到以下几点: 夯实基础。 一个老生常谈但又不得不坚持做的一件事, 万丈高楼平地起, 再高的楼房也是从打基础开始的。只有掌握好了基础知识, 无论是阅读代码还是自己编写时才能得心应手, 信手拈来。无论新出的框架如何变化, 其底层实现也就那样。 具有强迫症精神。要勇于挑战自己, 严格要求自己, 要敢于重构已有代码, 好的代码都是一行一行深思熟虑的结果。 积极拥抱开源。一定程度上, 开源项目已经积累了众多优秀大佬的实现思想, 特别是知名项目, 经过不断的重构迭代, 提炼出来的思想都是我们平常接触不到的。 最后用一句勉励自己的话来结束这篇文章: 代码是用来阅读的, 只是顺便实现了功能","categories":[{"name":"其他","slug":"其他","permalink":"https://alisdon.github.com/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://alisdon.github.com/tags/其他/"}]},{"title":"pnpm在做什么","slug":"pnpm在做什么","date":"2022-08-03T13:07:16.000Z","updated":"2022-08-10T14:13:12.620Z","comments":true,"path":"包管理器/pnpm在做什么/","link":"","permalink":"https://alisdon.github.com/包管理器/pnpm在做什么/","excerpt":"","text":"简介 pnpm和npm/yarn本质是相同, 都是一个包管理工具, 但相对npm和yarn而言具有如下特征: 节约磁盘空间并提升安装速度 创建非扁平化的 node_modules 文件夹 这是官方所表达设计pnpm的初衷! 依赖管理方式嵌套结构npm1/npm2采用的是和package.json文件中依赖与次依赖形成的树形结构而生成的node_modules目录结构, 再通过递归安装所有次级依赖所依赖的模块. 以项目中安装了 A | B 两个模块, A 模块依赖了 C | D 模块为例所生成的目录结构将如下所示: 123456node_modules├─ A@1.0.0| ├─ node_modules| | ├─ C@1.0.0| | ├─ D@1.0.0├─ B@1.0.0 对于这种各模块间互不关联的情景下如果不出意外这将是一个不错的解决方案, 但意外还是发生了. 以项目中安装了A | B 两个模块, A | B 同时依赖了 C | D 模块为例所生成的目录结构如下所示: 123456789node_modules├─ A@1.0.0| ├─ node_modules| | ├─ C@1.0.0| | ├─ D@1.0.0├─ B@1.0.0| ├─ node_modules| | ├─ C@1.0.0| | ├─ D@1.0.0 此时我们就可以发现2个问题 相同包重复安装, 将导致项目体积过大, 占用了过多的磁盘空间 依赖层级较深时引用地址将变得很长, 在window下将出现一些莫名问题. 社区里面也出现了诸如此类的“嘲讽”图片 扁平结构在这个阶段(目前npm和yarn都处于这个阶段), npm和yarn都将依赖进行了扁平化的管理即将依赖都提出到node_modules目录下, 不再有很深层次的嵌套关系. 以上方 A | B 模块都依赖 C | D 模块为例所生成的目录结构如下所示: 12345node_modules├─ C@1.0.0├─ D@1.0.0├─ A@1.0.0├─ B@1.0.0 对于扁平化后的目录结构, 根据 node require 的加载机制，会不停往上级的node_modules当中去找，如果找到相同版本的包就不会重新安装，这解决了大量包重复安装的问题，而且依赖层级也不会太深。 同样, 理想很丰满, 现实很骨感, 在我们平时使用中不可能会这么“规矩”. 比如我们在 B 模块中使用的是 D@1.0.1 这个版本而不是 D@1.0.0 这个版版, 新的流程将会是如下所示 1234567node_modules├─ C@1.0.0├─ D@1.0.0├─ A@1.0.0├─ B@1.0.0| ├─ node_modules| | ├─ D@1.0.1 亦或者 1234567node_modules├─ C@1.0.0├─ D@1.0.1├─ A@1.0.0| ├─ node_modules| | ├─ D@1.0.0├─ B@1.0.0 但由此却又诞生了“幽灵依赖” 和 “依赖分身”以及node_modules的结构不稳定性 幽灵依赖幽灵依赖是指在 package.json 中未定义的依赖，但项目中依然可以正确地被引用到。如例子中的 C | D 依赖 依赖分身依赖分身是指出现重名但不同版本的依赖安装, 此时的模块只能重复安装到模块所依赖的node_modules下, 若存在多个不同模块依赖与根node_modules不同的版本时将重复安装(此时和npm1/2嵌套时期生成的结构相同) 结构不确定性由于不同的操作系统对依赖的安装顺序不同, 在安装依赖时不同系统间将诞生不一样的目录结构. 而解决方案就是lock文件, 无论是package-lock.json(npm@5.x后出现)还是yarn.lock, 都是为了稳定的结构而诞生的. pnpm符号链接 符号连接又称为软链接, 类如window系统中的 快捷方式, 对符号链接文件进行读写的程序会表现得直接对目标文件进行操作. pnpm 的 node_modules 布局就是使用符号链接来创建依赖项的嵌套结构。在node_modules下存在一个全局的缓存池 .pnpm 文件夹, 在这个文件夹中将存放通过硬链接拷贝过来的真实文件, 通过符号连接访问时访问的其实是.pnpm中存在的目标文件. 还是以 A | B 模块都依赖 C | D 模块为例所生成的目录结构如下所示: 1234567891011121314151617181920node_modules├─ .pnpm| ├─ D@1.0.0| | ├─ node_modules| | | ├─ D -&gt; &lt;store&gt;/D| ├─ C@1.0.0| | ├─ node_modules| | | ├─ C -&gt; &lt;store&gt;/C| ├─ A@1.0.0| | ├─ node_modules| | | ├─ A -&gt; &lt;store&gt;/A| | | ├─ C -&gt; ../../C@1.0.0/node_modules/C| | | ├─ D -&gt; ../../D@1.0.0/node_modules/D| ├─ B@1.0.0| | ├─ node_modules| | | ├─ B -&gt; &lt;store&gt;/B| | | ├─ C -&gt; ../../C@1.0.0/node_modules/C| | | ├─ D -&gt; ../../D@1.0.0/node_modules/D├─ A@1.0.0 -&gt; ./.pnpm/A@1.0.0/node_modules/A├─ B@1.0.0 -&gt; ./.pnpm/B@1.0.0/node_modules/B 如果在 B 模块中使用的是 D@1.0.1 这个版本而不是 D@1.0.0 这个版版, 新的流程将会是如下所示 1234567891011121314151617181920212223node_modules├─ .pnpm| ├─ D@1.0.0| | ├─ node_modules| | | ├─ D -&gt; &lt;store&gt;/D| ├─ D@1.0.1| | ├─ node_modules| | | ├─ D -&gt; &lt;store&gt;/D| ├─ C@1.0.0| | ├─ node_modules| | | ├─ C -&gt; &lt;store&gt;/C| ├─ A@1.0.0| | ├─ node_modules| | | ├─ A -&gt; &lt;store&gt;/A| | | ├─ C -&gt; ../../C@1.0.0/node_modules/C| | | ├─ D -&gt; ../../D@1.0.0/node_modules/D| ├─ B@1.0.0| | ├─ node_modules| | | ├─ B -&gt; &lt;store&gt;/B| | | ├─ C -&gt; ../../C@1.0.0/node_modules/C| | | ├─ D -&gt; ../../D@1.0.1/node_modules/D├─ A@1.0.0 -&gt; ./.pnpm/A@1.0.0/node_modules/A├─ B@1.0.0 -&gt; ./.pnpm/B@1.0.0/node_modules/B 这里借用一下官方的关联关系图 由上方代码结构和官方关系图可得知如下结果: 相同的依赖只会安装一次, 不同模块间相同的依赖, 通过符号链接进行关联. 解决了重复安装、依赖分身的问题. 根节点只存在package.json中所注入的依赖, 解决了幽灵依赖的问题. 是用符号链接的方式即解决了依赖路径过长的问题. 所以基于链接的优势, pnpm 的安装速度会比npm/yarn快近2倍的优势, 同时也大大节约了磁盘的占用空间 对比图针对上方一系列的操作后, 效果如下: 是否pnpm就是最好的解决方案?首先任何一个解决方案都是当下最好的一个解决方案, 但并不代表这将是最终方案. pnpm依旧存在以下问题: 符号链接兼容性. 存在符号链接不能适用的一些场景，比如 Electron 应用、部署在 lambda 上的应用无法使用 pnpm 子依赖被提升到同级的目录结构. 虽然由于 Node.js 的父目录上溯寻址逻辑，可以实现兼容。但对于类似 Egg、Webpack 的插件加载逻辑，在用到相对路径的地方，需要去适配 不同应用的依赖是硬链接到同一份文件，如果在调试时修改了文件，有可能会无意中影响到其他项目 包管理器的探索DenoNode.JS作者Ryan在JSConf上曾表示node_modules是他对Node的十大遗憾之一, 并在后续介绍并推荐了自己的新作Deno. 在Deno中不需要package.json和node_modules，而是将引入源、包名、版本号、模块名全部塞进了 URL 里，通过URL导入依赖并进行全局统一缓存，不仅节省了磁盘空间，也优化了项目结构。 1import * as asserts from 'https://deno.land/std@0.125.0/testing/asserts.ts'; 因此Deno中没有包管理器的概念，对于项目中的依赖管理，Deno提供了这样一种方案。由开发者创建dep.ts，此文件中引用了所有必需的远程依赖关系，并且重新导出了所需的方法和类。本地模块从dep.ts统一导入所需方法和类，避免单独使用URL导入外部依赖可能造成的不一致的问题。 12345678// dep.tsimport &#123; asset, assetEquals &#125; from 'https://deno.land/std@0.125.0/testing/asserts.ts';// index.tsimport &#123; asset &#125; from './deps.ts'; yarn Plug’n’Play(yarn PnP)yarn 也意识到了在之前版本里存在的问题, 于是在2020年1月发布了v2版本的重大更新, 其中一项重要更新就是 Plug’n’Play（Plug’n’Play = Plug and Play = PnP，即插即用）。 现阶段 yarn install 操作会执行以下 4 个步骤： 将依赖包的版本区间解析为某个具体的版本号 下载对应版本依赖的 tar 包到本地离线镜像 将依赖从离线镜像解压到本地缓存 将依赖从缓存拷贝到当前目录的 node_modules 目录 其中第 4 步同样涉及大量的文件 I/O，导致安装依赖时效率不高（尤其是在 CI 环境，每次都需要安装全部依赖）。 PnP 的具体工作原理是: 作为把依赖从缓存拷贝到 node_modules 的替代方案，Yarn 会维护一张名为 .pnp.js 文件的静态映射表，该表中包含了以下信息： 当前依赖树中包含了哪些依赖包的哪些版本 这些依赖包是如何互相关联的 这些依赖包在文件系统中的具体位置 .pnp.js 文件中还包含了一个特殊的 resolver，Yarn 会利用这个特殊的 resolver 来处理 require() 请求，该 resolver 会根据 .pnp.js 文件中包含的静态映射表直接确定依赖在文件系统中的具体位置，从而避免了现有实现在处理依赖引用时的 I/O 操作。","categories":[{"name":"包管理器","slug":"包管理器","permalink":"https://alisdon.github.com/categories/包管理器/"}],"tags":[{"name":"pnpm","slug":"pnpm","permalink":"https://alisdon.github.com/tags/pnpm/"}]},{"title":"小程序申请步骤及条件","slug":"小程序申请步骤及条件","date":"2021-08-14T05:55:37.000Z","updated":"2021-09-02T02:04:45.186Z","comments":true,"path":"小程序/小程序申请步骤及条件/","link":"","permalink":"https://alisdon.github.com/小程序/小程序申请步骤及条件/","excerpt":"","text":"基本材料 邮箱账号(可以登录接受信息的, 并且没有注册过微信相关的应用) 小程序Logo 小程序名称 微信公众帐号主体 个人 身份证姓名 身份证号码 管理员手机号码 企业 企业类型 企业名称 营业执照注册号 注册方式 微信认证, 此方式将支付300元审核费用 企业对公账号, 此方式需要《开户名称》、《开户银行》、《对公账户》、《开户地点》 管理员身份证姓名 身份证号码 手机号码 服务类目 《工具 &gt; 效率》、《工具 &gt; 信息查询》、《商业服务 &gt; 一般财务服务》、《商业服务 &gt; 公关/推广/市场调查》、 不需要其他资料 其中除《商业服务 &gt; 一般财务服务》外, 个人主体的小程序都能选择 其他类目 请点击此处查看 以上服务类目1为我觉得合适的类目, 如果不合适可以再查看其他的类目 建议先用《个人主体》下的服务类目1的账号进行提交审核, 如果失败再结合微信审核反馈的信息进行调整","categories":[{"name":"小程序","slug":"小程序","permalink":"https://alisdon.github.com/categories/小程序/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://alisdon.github.com/tags/微信小程序/"}]},{"title":"微信小程序发布流程","slug":"微信小程序发布流程","date":"2021-06-26T09:41:49.000Z","updated":"2021-09-02T02:04:31.467Z","comments":true,"path":"小程序/微信小程序发布流程/","link":"","permalink":"https://alisdon.github.com/小程序/微信小程序发布流程/","excerpt":"","text":"微信小程序发布流程 鉴于密码库小程序开发已经完成, 所以本文将从以下几个方面对小程序发布流程做说明: 小程序登录 小程序如何生成体验版? 小程序如何提交审核? 小程序如何发布? 小程序审核过程中的注意事项. 1. 小程序登录 打开微信公众平台(mp.weixin.qq.com/), 使用微信扫码(拥有密码库小程序管理权限的微信)或者账号登录(注册密码库小程序的账号密码), 进入微信小程序管理后台并点击左侧版本管理菜单 2. 小程序如何生成体验版?登录成功后, 点击左侧菜单-版本管理 注意到版本管理最后一栏中有个版本号为 0.0.7 的开发版本, 这是开发者通过微信开发工具提交上来的开发版本, 其中可以在此将设置体验版小程序, 操作步骤为: 点击开发版本栏中向下箭头的按钮, 找到选为体验版的选项 修改体验版的默认页面路径, 一般为默认路径不修改 点击提交生成体验版小程序, 此处二维码可扫码打开体验版小程序, 也可继续流程用其他途径打开 设置成功后, 关闭窗口可发现0.0.7版本号下面将提交一个体验版的小标签 点击二维码图标将可以通过扫码进行查看体验版 3. 小程序如何提交审核登录成功后, 点击左侧菜单-版本管理, 并点击开发版中的提交审核按钮 勾选复选框, 然后点击确认按钮 点击继续提交 上一步操作后将新打开一个标签页, 在此页面, 填写当前版本的描述, 其余的内容项在密码库小程序中不涉及, 所以可以不填写, 选择不加急处理(一年一次加急机会, 请在合适的时机再使用), 最后点击提交 如看到此页面则证明提交成功 点击确认按钮, 回到版本管理界面, 可看见审核版本栏将出现我们刚刚申请审核的版本(如若没有发现,请尝试刷新浏览器) 审核结果将在腾讯审核完成后通过微信公众平台公众号通知审核结果 审核通过 审核失败, 失败情况下, 腾讯将会反馈失败的原因, 根据原因进行调整后可进行二次提交审核的操作 4. 小程序如何发布 小程序发布, 必须在审核通过的状态下才能进行 登录成功后, 点击左侧菜单-版本管理, 点击提交发布 选择全量发布, 点击提交 微信扫描二维码, 手机确认发布 如若出现此界面则说明发布成功 5. 小程序审核过程中的注意事项鉴于密码库小程序的特殊性, 所以此处有一下几点需要注意&lt;!– 尽量不要修改多次提交审核. 由于私行小程序中包含了金融方面的知识, 所以腾讯在审核的时候很大程度会按照金融主体的企业进行考量审核 发布的版本描述中尽量不要出现金融相关的字眼, 理由同上–&gt; 使用与小程序内容相关的主体账号 小程序发布之后, 尽可能的放弃并删除体验版本与开发版本, 且不再继续给其他人进行申请通过, 此条为建议项","categories":[{"name":"小程序","slug":"小程序","permalink":"https://alisdon.github.com/categories/小程序/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://alisdon.github.com/tags/小程序/"}]},{"title":"微信小程序云开发","slug":"微信小程序云开发","date":"2021-06-24T09:41:49.000Z","updated":"2021-09-02T02:03:54.906Z","comments":true,"path":"小程序/微信小程序云开发/","link":"","permalink":"https://alisdon.github.com/小程序/微信小程序云开发/","excerpt":"","text":"微信小程序云开发是什么 小程序·云开发是微信团队联合腾讯云推出的专业的小程序开发服务。 开发者可以使用云开发快速开发小程序、小游戏、公众号网页等，并且原生打通微信开放能力。 开发者无需搭建服务器，可免鉴权直接使用平台提供的 API 进行业务开发。 以上为微信小程序官方给出的云开发解释, 简单的说云开发使用的是腾讯的服务器存储后端数据，传统的是自备服务器. 云开发的优缺点开局先上对比图 优势说明由上图可以看出 传统开发模式 开发效率低：过多的非业务逻辑需要处理，导致开发效率难以提升 资源投入高：无论是物理机托管，还是云主机维护，都需要较多的人力物力投入 产品上线慢：前后端联调、资源存储、部署等操作繁杂，上线流程耗时长 日常运维难：需时刻关注环境运行状况，管理相关资源，运维难度大 云开发模式 高效开发：只需编写核心逻辑代码，内建小程序用户鉴权，无需关注后端配置与部署，专注于业务开发 节约成本：按请求数和资源的运行收费，极大节约时间和成本，提供一定量免费额度使用 官方生态：原生集成微信SDK，云相关API开箱即用；同时，通过云调用，可免鉴权直接调用微信开放接口 稳定可靠：底层资源由腾讯云提供专业支持，满足不同业务场景和需求，具备快速拓展能力，确保服务稳定，数据安全 劣势说明 云函数运算时间不得超过3秒。超过3秒未处理完成，直接返回错误 云函数单次返回数据不得超过1M。超过1M直接报错 云函数读取数据库较慢。云函数 云数据库感觉应该在同一物理环境下，但其实并不是，应该处于不同的云端，因为读取100次数据就已经超过3秒了 云函数并发次数有限。这个文档里面配额写得很清楚，免费版并发数只有20次，这里的并发估计是每秒钟调用次数，因为确实很慢很慢, 据实践，每隔半秒调用一个云函数, 调用100遍，还是报告调用次数超限 云函数不适合做数据库的较大数量查询功能, 只适合进行10条左右的敏感数据读取，如用户信息等。 云函数读取云数据库单次最多读取100条。超过100条需要使用 skip() ,分多次将数据组合起来。 小程序前端读取云数据库单次最多读取20条。 对外开放限制多。由于小程序云开发自带的云数据库在小程序内部，外部要是想访问这个数据库则需要一个稍微复杂的流程：先使用官方接口获取到调用凭证，在通过这个凭证使用指定的接口来对数据库进行增删改查。此外这个流程中消耗的资源也是算在基础配置里的，每日请求上线5万次 后期移植不方便, 无法支持通用框架。如果企业完全使用云开发开发小程序，然后由于某种原因不能使用这种方式了，想独立部署后端的话，将要面临如何移植的问题。云开发太依赖微信平台了。 云开发后期是否能够剥离出来使用自己的服务器 通过云函数转私有服务器调用接口 修改小程序直接调用私有服务器接口, 其中登录状态还是又云函数提供 云开发计费模式云开发计费方式目前分为三种: 预付费：个人账户扣款：适用于个人账户结算的小程序，目前仅支持微信支付 预付费：腾讯云账户扣款：适用于通过腾讯云账户统一结算的小程序 按量付费：腾讯云账户扣款：适用于暂时无法准确预估使用量的小程序，目前仅支持从腾讯云账户扣款 系统默认使用的支付方式为按量付费：腾讯云账户扣款 点击查看具体云开发计费相关 云开发计费方式需要注意的有: 切换至按量计费后无法再切换支付方式 从账户余额被扣为负值时刻起，小程序·云开发资源在 12 小时内可继续使用且继续扣费，12 小时后未及时充值，系统将自动隔离资源且停止扣费。 7*24 小时后，若账户余额未充值到大于 0，按量计费环境将被回收。届时环境中的数据将被清除且不可恢复 总结根据目前情况来看, 小程序云开发是一个比较合适应用的一种开发模式, 在本应用中需要做以下几种处理: 开通云开发静态资源管理 开通云开发内容管理平台, 对应切换至按量付费方式","categories":[{"name":"小程序","slug":"小程序","permalink":"https://alisdon.github.com/categories/小程序/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://alisdon.github.com/tags/小程序/"}]},{"title":"als-block-wxmp 插件使用说明","slug":"als-block-wxmp","date":"2020-07-17T09:41:49.000Z","updated":"2022-08-10T14:51:22.100Z","comments":true,"path":"als-block/als-block-wxmp/","link":"","permalink":"https://alisdon.github.com/als-block/als-block-wxmp/","excerpt":"","text":"页面拦截由于系统存在部分需要登录和输入锁屏密码的界面, 所以该拦截存在以下配置项: 属性 默认值 说明 auth true 是否需要授权 authRouterType redirectTo 跳转到授权页面的方式 authPage ‘’ 授权页面路径 login true 是否需要登录 loginRouterType redirectTo 跳转到登录页面的方式 loginPage ‘’ 登录页面路径 12345678910111213141516171819// 注册拦截器const &#123; Interceptor &#125; = require('./al-wxmp.min.js');new Interceptor(&#123; auth: true, authRouterType: 'redirectTo', authPage: '/pages/login/auth/auth', login: true, loginRouterType: 'reLaunch', loginPage: '/pages/login/auth/auth'&#125;)// 使用拦截器Page(&#123; interceptor: &#123; auth: true, login: false &#125;&#125;) 路由函数由于小程序中带有参数的页面跳转略微复杂, 所以对页面跳转进行一层包裹 1234567891011121314151617181920const &#123; Router &#125; = require('./al-wxmp.min.js');// 保留当前页面，跳转到应用内的某个页面Router.navigateTo( '/pages/index/index', &#123; id: 1234567890 &#125;, &#123; auth: false &#125;)// 关闭所有页面，打开到应用内的某个页面Router.reLaunch( '/pages/index/index', &#123; id: 1234567890 &#125;, &#123; auth: false &#125;)// 关闭当前页面，跳转到应用内的某个页面Router.redirectTo( '/pages/index/index', &#123; id: 1234567890 &#125;, &#123; auth: false &#125;) Tips: 路由组件传递参数格式一致, 均为(路径[String], 参数[String|Object], 拦截器参数(不传则使用注册拦截器时的参数配置)) 请求组件由于请求能够做到更多的复用, 所以将此进行封装 实例化配置项 属性 默认值 说明 baseUrl 默认请求地址(后端网关地址) hideErrMsg false 是否隐藏错误信息 needReject false 是否需要 Promise 的 catch 分之 isSuccess (data) =&gt; data.code === 0 是否成功的判断 showErrMsgFn (error) =&gt; error.msg “” 返回错误信息的函数 请求配置项 属性 默认值 说明 baseUrl 默认请求地址(后端网关地址) hideErrMsg false 是否隐藏错误信息 needReject false 是否需要 Promise 的 catch 分之 headers 需要携带的headers 1234567891011121314151617181920212223242526272829// 注册请求const &#123; Request &#125; = require('./al-wxmp.min.js');new Request(&#123; baseUrl: 'http://120.27.27.108:3000/', hideErrMsg: false, needReject: false, isSuccess: (data) =&gt; data.code === 0, showErrMsgFn: (error) =&gt; error.msg || \"\",&#125;);// GET 使用, 隐藏提示、返回catch分支Request.get( '/user/get', &#123; id: '123' &#125;, &#123; hideErrMsg: true, needReject: true &#125;).then(console.log).catch(console.error)// POST 使用, 设置headersRequest.post( '/user/save', &#123; name: 'Alisdon' &#125;, &#123; headers: &#123; 'Content-Type': 'application/json' &#125; &#125;).then(console.log)// 使用其他 baseUrlRequest.post( '/user/login', &#123; userName: 'Alisdon' &#125;, &#123; baseUrl: 'http://www.baidu.com' &#125;).then(console.log) 无论是GET还是POST最多能接受3个参数, 依次为请求地址, 请求参数, 请求配置项 消息组件由于消息存在大量的复用, 所以将此进行封装 12345678910111213const &#123; Message &#125; = require('./al-wxmp.min.js');// 注册消息组件wx.$message = Router;// 成功提示wx.$message.success('成功提示');// 成功提示wx.$message.error('错误提示');// 弹框提示wx.$message.modal('敏感操作, 是否继续?').then(() =&gt; &#123; wx.$message.success('操作成功')&#125;); 此处的成功和失败没有区分, 所以将表现一致, 但希望依旧按照业务使用, 方便后期修改 缓存组件本插件提供了便利的缓存功能, 其中内置了用户信息(userinfo)的处理 1234567891011const &#123; Storage &#125; = require('./al-wxmp.min.js');// 注册缓存wx.$storage = Storage;// 用户信息的获取const userInfo = wx.$storage.userinfo;// 用户信息的设置, 支持增量修改wx.$storage.userinfo = &#123; name: 'alisdon' &#125;// 清除用户信息wx.$storage.userinfo = 'clean'; 缓存组件还支持自定义扩展 方法名 参数 说明 extend (key, storageKey, type) =&gt; void key 为自定义扩展的关键属性, storageKey 为数据缓存的key, type 为需要缓存数据的类型, 支持 ‘string’ 和 ‘object’, 其中鉴于系统内置方法, key 不能使用 ‘userinfo’ 和 ‘extend’, storageKey 不能是用 ‘A_UI’ 12345678910111213const &#123; Storage &#125; = require('./al-wxmp.min.js');// 自定义扩展Storage.extend('token', 'A_TICKET', 'string');// 注册缓存wx.$storage = Storage;// 获取自定义的内容const token = wx.$storage.token;// 增量修改自定义内容wx.$storage.token = '1234567890'// 清除自定义信息wx.$storage.token = 'clean';","categories":[{"name":"als-block","slug":"als-block","permalink":"https://alisdon.github.com/categories/als-block/"}],"tags":[{"name":"als-block","slug":"als-block","permalink":"https://alisdon.github.com/tags/als-block/"}]},{"title":"als-block-crud 使用说明","slug":"als-block-crud","date":"2020-07-16T09:41:49.000Z","updated":"2022-08-10T14:51:16.577Z","comments":true,"path":"als-block/als-block-crud/","link":"","permalink":"https://alisdon.github.com/als-block/als-block-crud/","excerpt":"","text":"介绍Als-Block-Crud是一套基于Vue.js和Element UI的表格组件。als-block-crud 将 Element 的功能进行了封装。大部分功能可由配置 json 实现，在实现并扩展了 Element 表格组件功能的同时，降低了开发难度，减少了代码量，大大简化了开发流程。 文档 als-block-table 表格 als-block-form 表单 als-block-menu 菜单 als-block-dialog 模态框 功能 继承了 Element 中表格所有功能 继承了 Element 中表单所有功能 使用 Element 中的组件渲染表格内容和表单内容 表单校验 表格内编辑 渲染自定义组件 菜单 模态框 安装CDN1&lt;script src='./als-block-crud.min.js'&gt;&lt;/script&gt; 由于服务器过期, 可在底部联系作者 npm（暂未放入 npm）1npm i element-ui als-block-crud -S 在项目中使用在使用的时候需要对组件进行配置，以下为所有默认配置，使用时可自定义完善配置。项目配置以axios请求得到参数格式来进行案例说明： 1234567891011121314151617181920212223242526272829303132不分页返回的格式&#123; ...axios.response, status: 200, statusText: 'OK', data: &#123; &#123; code: 200, data: [], msg: '' &#125; &#125;&#125;分页返回的格式&#123; ...axios.response, status: 200, statusText: 'OK', data: &#123; &#123; code: 200, data: &#123; list: [], pageSize: 10, pageIndex: 1, total: 10 &#125; msg: '' &#125; &#125;&#125; 在main.js中写入以下内容： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394import Vue from \"vue\";import ElementUI from \"element-ui\";import \"element-ui/lib/theme-chalk/index.css\";Vue.use(ElementUI);Vue.use(window.AlsBlockCrud, &#123; table: &#123; // 分页相关配置 pagination: &#123; // 布局 layout: \"sizes, prev, pager, next, total, -&gt;\", // 下拉框的选项 sizes_value: [10, 20, 50, 100], // 每页显示条数的key size: \"pageSize\", // 每页显示条数的默认值 size_default_value: 10, // 当前页的key index: \"pageIndex\", // 当前页的默认值 index_default_value: 1, // 总条数的key total: \"total\", &#125;, // 分页时数据源路径 path_data: \"data.data.list\", // 不分页时的数据源路径 path_data_no_pagination: \"data.data\", // 每页显示条数的路径 path_size: \"data.data.pageSize\", // 当前页的路径 path_index: \"data.data.pageIndex\", // 总条数的路径 path_total: \"data.data.total\", // 列表默认高度，可在使用中覆盖，可设置['auto', '100%', Number + 'px'] height: \"auto\", // 是否默认开启边框，可在使用中覆盖 border: true, // 是否默认开启斑马条纹，可在使用中覆盖 stripe: true, // 默认表头样式，可在使用中覆盖 header_cell_style: &#123;&#125;, // 展示加载中 show_loading: true, // 字典映射 dict_props: &#123; // 映射的 value value: \"value\", // 映射的 名称 label: \"label\", // 如果没有对应值需要显示的内容 emptyValue: \"\", &#125;, // 请求失败的回调 on_request_error: function(error) &#123; // 获取服务端返回的 data 值 const serverResult = error.data || &#123;&#125;; // 提示信息 this.$message.error(serverResult.msg || \"系统错误\"); &#125;, &#125;, form: &#123; // 表单验证触发方式 trigger: [\"blur\", \"change\"], // 是否需要验证特殊字符 need_valid_special_chart: true, // 手机号正则 valid_regexp_phone: /1[3-9][0-9]&#123;9&#125;$/, // 邮箱正则 valid_regexp_email: /^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$/, // ip正则 valid_regexp_ip: /^(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5])(\\.(\\d&#123;1,2&#125;|1\\d\\d|2[0-4]\\d|25[0-5]))&#123;3&#125;$/, // 编码正则 valid_regexp_code: /^[a-zA-Z0-9]+$/, // 特殊字符正则 valid_regexp_special_chart: /[`~!@#$%^&amp;*()_\\-+=&lt;&gt;?:\"&#123;&#125;|,.\\/;'\\\\[\\]·~！@#￥%……&amp;*（）——\\-+=&#123;&#125;|《》？：“”【】、；‘’，。、 ]/gim, // 默认属性 default_options: &#123; // 行占比 span: 24, // 行间距 gutter: 0, // 输入框默认属性 input: &#123;&#125;, // 下拉框默认属性 select: &#123;&#125;, &#125;, &#125;,&#125;);new Vue(&#123; el: \"#app\", render: (h) =&gt; h(App),&#125;); 至此，你就可以愉快的使用Als-Block-Crud组件了 联系我","categories":[{"name":"als-block","slug":"als-block","permalink":"https://alisdon.github.com/categories/als-block/"}],"tags":[{"name":"als-block","slug":"als-block","permalink":"https://alisdon.github.com/tags/als-block/"}]},{"title":"als-block-dialog 使用说明","slug":"als-block-crud/dialog","date":"2020-07-16T09:41:49.000Z","updated":"2022-08-10T14:04:06.596Z","comments":true,"path":"als-block/als-block-crud/dialog/","link":"","permalink":"https://alisdon.github.com/als-block/als-block-crud/dialog/","excerpt":"","text":"模态框Als-Block-Crud对模态框进行了二次封装，意为开发带来更多的便利，减少开发时多余代码的Ctrl+c、Ctrl+v。 功能说明 关闭即摧毁 多配置底部区域 props 对象123456789dialogMap: &#123; options: &#123; title: '模态框'， showClose: true &#125;, footer: &#123; onSubmitClick: this.dialogSave &#125;&#125; 配置说明 属性名 说明 默认值 options 其他绑定属性 footer 窗体底部配置 options为element-ui的组件配置 底部说明 - footer 配置 属性名 说明 默认值 showCancelButton 是否显示取消按钮 true cancelButtonText 取消按钮文本 取 消 showSubmitButton 是否显示确定按钮 true submitButtonText 确定按钮文本 确 定 onCancelClick 点击取消按钮事件 只想\\$emit(‘close’)事件 onSubmitClick 点击确定按钮事件 事件 事件名 说明 返回值 close 关闭模态框事件 无 方法 方法名 说明 返回值 open 打开模态框 无 close 关闭模态框 无 底部按钮可通过slot为footer的插槽进行扩展 案例1234567891011121314151617181920212223242526&lt;template&gt; &lt;el-button type=\"primary\" @click=\"handleOpenDialog\"&gt;打开模态框&lt;/el-button&gt; &lt;als-block-dialog ref=\"AlBlockDialog\" :dialog-map=\"dialogMap\" /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'AlBlockMenu', data () &#123; return &#123; dialogMap: &#123; options: &#123; title: '模态框' &#125; &#125; &#125; &#125;, methods: &#123; handleOpenDialog () &#123; this.$refs.AlBlockDialog.open() &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"als-block","slug":"als-block","permalink":"https://alisdon.github.com/categories/als-block/"}],"tags":[{"name":"als-block","slug":"als-block","permalink":"https://alisdon.github.com/tags/als-block/"}]},{"title":"als-block-table 使用说明","slug":"als-block-crud/table","date":"2020-07-16T09:41:49.000Z","updated":"2022-12-09T08:48:24.347Z","comments":true,"path":"als-block/als-block-crud/table/","link":"","permalink":"https://alisdon.github.com/als-block/als-block-crud/table/","excerpt":"","text":"列表篇Als-Block-Crud对列表进行了二次封装，意为开发带来更多的便利，减少开发时多余代码的Ctrl+c、Ctrl+v。 功能说明 本地数据或远程数据展示 初始选中状态设置 集成分页组件 自定义列表项 兼容element-ui所有属性 本地数据分页 props 对象12345678910111213141516selectedKeys: ['1']tableMap: &#123; options: &#123;&#125;, columns: [], dataSource: [], listeners: &#123;&#125;&#125;pagination: &#123; pageSizes: [10, 20, 50, 100], pageSize: 10, pageIndex: 1, total: 0, layout: 'sizes, prev, pager, next, total, -&gt;'&#125; pagination为所见参数配置，默认开启，设置 boolean 类型的 false 则关闭，开启时需在引用组件时进行配置使用，如获取pageSize的路径 pageSize和pageIndex为本次案例使用的分页信息，实际使用中请配置成项目字段 tableMap.dataSource为列表数据源，优先使用 tableMap.listeners为列表事件监听集合，可自由添加配置 selectedKeys为选中行的 key 值，需要在table/options下设置行关键值currentRowKey，currentRowKey默认为id options 对象 属性名 说明 类型 函数参数 默认值 immediately 是否在页面加载完成立即请求列表数据 Boolean/Function 无 true requestApi 请求列表数据函数，需返回 Promise 对象 Function 无 requestParams 除去分页信息外的参数对象，可直接传入 JSON 对象或提供返回值为 JSON 对象的函数 Object/Function 无 deleteApi 删除数据地址，需返回 Promise 对象，参数来自调用删除方法时传入的值 Function 无 firstCellType 第一列类型。有效值selection、index、expand、none， 为 expand 时在组件中嵌入名称为expand的作用域插槽（与其他行取值一致）, none为不显示 String/Function 无 selection headerCellStyle 表头样式，可在引用组件时进行配置使用 Object 不可使用函数 无 onRequestSuccess 请求成功的回调 Function xhrResponse onRequestError 请求失败的回调 Function error 依赖全局配置中 table.on_request_error … elementUI 表格的其他属性，可自由配置 不可使用函数 height、stripe、border已在引用组件时进行配置使用 ref 由于 ref 值非响应数据，故封装的时候将el-table的ref确定为alBlockTable columns 数组对象 属性名 说明 类型 函数参数 默认值 field 映射标识 String/Function 无 label 显示名称 String/Function 无 show 是否显示 Boolean/Function 无 true slot 插槽名 String/Function 无 dicts 字典数据, 数组内容由注册时决定 Array/Function 无 如传入[{ value: ‘1’, label: ‘文本’, type: ‘primary’ }] , value 和 label 由注册时映射. type 为 elTag 的type, 不传则直接显示文本 render 列渲染函数。可编写render 函数，或安装 jsx 插件进行开发 Function (当前行相关信息, 渲染函数) handle 操作项数组，见下方操作项说明 Array 无 options elementUI 表格的其他属性，可自由配置 Object 不可使用函数 {immediately: true, currentRowKey: ‘id’, firstCellType: ‘selection’, headerCellStyle: 取决于全局配置, height: 取决于全局配置,stripe: 取决于全局配置,border: 取决于全局配置} listener elementUI 表格的事件，可自由配置 Object 无 方法 方法名 功能 接受参数类型 用途 loadTableData 重载列表数据，需提供 requestApi，返回 Promise 对象可使用 无 表单编辑、列表删除后刷新页面 searchTableData 根据传入的对象查询列表数据，需提供 requestApi，返回 Promise 对象可使用 Object 搜索 batchDelTableData 批量删除数据，自动检测是否勾选数据，需提供 deleteApi，返回 Promise 对象可使用 任意，默认为{ids: 以,分割勾选的 id 值} 批量删除 delTableData 删除数据，需提供 deleteApi，返回 Promise 对象可使用 任意，默认为{id: id} 删除单条数据 toggleRowSelection 切换行选中状态，根据传入的行 key 进行勾选显示，需提供 currentRowKey,默认为 id ArrayStringFunction 单选列表或多选列表选中或取消选中 操作项 handle 说明12345678handle: [&#123; html: '&lt;i class=\"el-icon-edit\"&gt;&lt;/i&gt;编辑',// 当前按钮的html show: rows =&gt; rows.row.age &gt; 18, // 是否显示 disabled: rows =&gt; rows.row.age &gt; 18, // 是否不可用 type: 'button', // 按钮类型 style: '', // 按钮样式 click: rows =&gt; console.log(rows) // 按钮点击事件&#125;] 以上参数可直接返回字符串，也可以执行传入当前行数据的函数 案例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;template&gt; &lt;als-block-table ref='mainTable' :table-map='tableMap'&gt;&lt;/als-block-table&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'AlsBlockTable', data () &#123; return &#123; tableMap: &#123; options: &#123; requestApi: (params) =&gt; axios.get('get', params), requestParams: &#123; orgId: '1' &#125;, deleteApi: (params) =&gt; axios.delete('del', params), &#125;, columns: [ &#123; field: 'name', label: '姓名' &#125;, &#123; field: 'age', label: '年龄', render: (&#123; row &#125;, h) &#123; return row.age &gt; 18 ? h('span', &#123;&#125;, '成人') : h('span', &#123;&#125;, '未成年') &#125; &#125;, &#123; field: 'sex', label: '性别', dicts: [ &#123; label: '男', value: 1, type: 'default' &#125;, &#123; label: '女', value: 0, type: 'warning' &#125;, ] &#125;, &#123; field: '', label: '操作', options: &#123; width: '120px' &#125;, handle: [&#123; html: '&lt;i class=\"el-icon-edit\"&gt;&lt;/i&gt;编辑', type: 'primary', click: rows =&gt; &#123; console.log(rows) &#125; &#125;, &#123; html: '&lt;i class=\"el-icon-delete\"&gt;&lt;/i&gt;删除', type: rows =&gt; rows.row.age &gt; 22 ? 'primary' : 'danger', click: (&#123;row&#125;) =&gt; &#123; console.log(row); this.$refs.mainTable.delTableData(&#123;id: row.id&#125;) &#125; &#125;] &#125; ] &#125; &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"als-block","slug":"als-block","permalink":"https://alisdon.github.com/categories/als-block/"}],"tags":[{"name":"als-block","slug":"als-block","permalink":"https://alisdon.github.com/tags/als-block/"}]},{"title":"als-block-form 使用说明","slug":"als-block-crud/form","date":"2020-07-16T09:41:49.000Z","updated":"2022-08-10T14:03:36.982Z","comments":true,"path":"als-block/als-block-crud/form/","link":"","permalink":"https://alisdon.github.com/als-block/als-block-crud/form/","excerpt":"","text":"表单篇Als-Block-Crud对表单进行了二次封装，意为开发带来更多的便利，减少开发时多余代码的Ctrl+c、Ctrl+v。 功能说明 简化表单校验开发代码 分离提交参数 自定义表单项 表单项描述 兼容element-ui所有属性 控制单项宽度 props 对象12345formMap: &#123; options: &#123;&#125;, formData: &#123;&#125;, formComponents: []&#125; formData为最后提交的参数，不做描述 options 对象 属性名 说明 默认值 column 显示配置，详情点击此处，也可直接传Number设置span的值 submitApi 请求地址，需返回Promise对象 submitBefore 保存前函数，需返回带传递参数的Promise对象 labelWidth label的宽度 80px labelPosition label的位置 right … element-ui表单的其他属性，可自由配置 列显示配置 属性名 说明 默认值 gutter 每列展示间隔，可在引入时配置默认值 0 span 每列展示所占用的比列，共 24 等分，可在引入时配置默认值 24 … element-ui组件col的其他属性，可自由配置 formComponents 数组 属性名 说明 类型 函数参数 默认值 label 显示文本 String/Function (formData) component 元素类型，有效值:input,number,textarea,select,checkbox,radio,switch,date,button,render String name 对应 formData 中的 key String/Function (formData) show 是否显示 Boolean/Function (formData) true column 列配置，element-ui中col的配置项 Object/Function (formData) disabled 是否不可用 Boolean/Function (formData) false rules 校验规则，详情点击此处 Object/Array/Function (formData) listeners 事件处理集合 Object options elementUI 表单元素其他绑定属性 dataSource 数据源，用于 radio，checkbox，select，render 组件的数据配置 根据元素类型确定，详情见下方 dataSource的运用 description 描述 String/Function (formData) 方法 事件名 说明 返回值 submit 提交的方法，需要和submitApi配合使用 提交请求后的Promise对象 valid 表单校验 Boolean类型的true/false reset 重置表单 无 表单校验 rules 说明1234567891011121314151617181920212223242526272829303132333435363738394041424344454647rules: &#123; required: true, // 开启必填校验 required: &#123; message: '请输入xxx' // 错误时提示的消息，见下方说明 &#125;, required: [&#123; required: true, message: '请输入xxx', trigger: ['change', 'blur'] &#125;], phone: true, // 开启手机号校验 phone: &#123;&#125;, email: true, // 开启邮箱校验 email: &#123;&#125;, number: true, // 开启数字校验 number: &#123;&#125;, code: true, // 开启数字和字母校验 code: &#123;&#125;, port: true, // 开启端口校验 port: &#123;&#125;, ip: true, // 开启ip校验 ip: &#123; contain: 'localhost' // 可传入数组或以,分割的字符串 &#125;, integer: true, // 开启整数校验 integer: &#123; positive: true, // 正整数，与负整数二选一 negative: true, // 负整数，与正整数二选一 containZero: true,// 是否包含0， 在正负整数设置时有效 min: 1, // 最小值 max: () =&gt; 10, // 最大值 &#125;, length: &#123; min: 1, // 最小值 max: () =&gt; 10, // 最大值 len: 5 // 特定长度 &#125;, regular: &#123; pattern: /./ &#125;, specialChar: &#123; message: char =&gt; `存在非法字符$&#123;char&#125;`, // 自定义提示可接受过滤后所包含的的特殊字符 filter: 'all' // 过滤所有特殊字符 filter: '@s.' // 过滤@.两个特殊字符（以s分割的字符串） filter: [\"@\", \".\"] // 过滤@.两个特殊字符 &#125;&#125; 可传返回对应类型的函数或对应类型数据，如length中最大值和最小值的用法等效。 若只需开启某规则不定义其他属性，可直接设置 true 属性，反之亦然。可设置 Boolean 类型的已全部罗列上方说明，如required。 若当前规则需要添加其他属性，可使用 Object 对象进行配置，规则为 Object 对象时也为开启状态。如required。 message都存在默认提示，不传则使用默认提示。 可传入支持elementUI封装的数据格式。 组件 input 说明1234567891011121314151617&#123; label: '输入框', component: 'input', show: () =&gt; true, name: 'input', rules: &#123; required: &#123; message: '请输入输入框' &#125; &#125;, options: &#123; slots: &#123; prefix: (data, h) =&gt; h('i', &#123; class: 'el-icon-search' &#125;) &#125; &#125;, description: '这是一条说明'&#125; 此处slot对象 key 需要和 input 框slot的name对应,否则将不会生效。可接受表单数据和render 函数进行渲染 组件 render 说明以 el-color-picker 色彩选择器为例 1234567891011121314151617&#123; label: 'render组件', component: 'render', name: 'render', dataSource: (formData, h) =&gt; &#123; return h(\"el-color-picker\", &#123; props: &#123; value: formData.render &#125;, on: &#123; change: val =&gt; &#123; this.$set(formData, 'render', val) &#125; &#125; &#125;); &#125;&#125; 此处dataSource接收当前表单数据和渲染函数，可通过此函数进行render 函数的渲染 案例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174&lt;template&gt; &lt;als-block-form ref='mainForm' :formMap=\"formMap\" /&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; formMap: &#123; options: &#123; submitApi: axios.post('save') &#125;, formData: &#123; input: '', number: 0, textarea: '', date: new Date(), select: '1', checkbox: ['1'], radio: '1', switch: 1, render: '' &#125;, formComponents: [&#123; label: '输入框', component: 'input', name: 'input', show: (formData) =&gt; Boolean(formData.id), // 当存在id时显示 rules: &#123; required: &#123; message: '请输入输入框' &#125; &#125;, listeners: &#123; change: value =&gt; console.log(value) &#125;, options: &#123; placeholder: '请输入输入框', slots: &#123; prefix: (data, h) =&gt; h('i', &#123; class: 'el-icon-search' &#125;) &#125; &#125; &#125;, &#123; label: '数字框', component: 'number', name: 'number', show: () =&gt; true, disabled: () =&gt; false, rules: [], description: '这是一个数字框' &#125;, &#123; label: '文本框', component: 'textarea', name: 'textarea', show: () =&gt; true, disabled: () =&gt; false, options: &#123; autosize: &#123; minRows: 1, maxRows: 3 &#125; &#125; &#125;, &#123; label: '日期', component: 'date', name: 'date', show: () =&gt; true, disabled: () =&gt; false &#125;, &#123; label: '下拉框', component: 'select', name: 'select', show: () =&gt; true, disabled: () =&gt; false, dataSource: [&#123; value: '1', label: '下拉框', disabled: true &#125;, &#123; value: '2', label: '下拉框2', disabled: false &#125;] &#125;, &#123; label: '复选框', component: 'checkbox', name: 'checkbox', show: () =&gt; true, disabled: () =&gt; false, dataSource: [&#123; value: '1', label: '复选框1' &#125;, &#123; value: '2', label: '复选框2' &#125;] &#125;, &#123; label: '单选框', component: 'radio', name: 'radio', show: () =&gt; true, disabled: () =&gt; false, dataSource: [&#123; value: '1', label: '单选框1' &#125;, &#123; value: '2', label: '单选框2' &#125;] &#125;, &#123; label: '开关', component: 'switch', name: 'switch', show: () =&gt; true, disabled: () =&gt; false, options: &#123; activeValue: '1', inactiveValue: '0' &#125; &#125;, &#123; label: '按钮', component: 'button', show: () =&gt; true, listeners: &#123; click: _ =&gt; console.log(this.formMap.formData) &#125;, dataSource: [&#123; html: '&lt;i class=\"el-icon el-icon-plus\"&gt;&lt;/i&gt;&lt;span&gt;按钮&lt;/span&gt;', type: 'primary', style: 'width: 100%', click: formData =&gt; console.log(formData) &#125;] &#125;, &#123; label: 'render组件', component: 'render', name: 'render', show: () =&gt; true, disabled: () =&gt; false, dataSource: (data, h) =&gt; &#123; return h(\"el-color-picker\", &#123; props: &#123; value: this.formMap.formData.render &#125;, on: &#123; change: val =&gt; &#123; this.$set(this.formMap.formData, 'render', val) &#125; &#125; &#125;); &#125; &#125;] &#125; &#125;, methods: &#123; /** * 提交表单 */ handleBtnClick () &#123; this.$refs.mainForm.submitForm().then(res =&gt; &#123; console.log(res) &#125;) &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"als-block","slug":"als-block","permalink":"https://alisdon.github.com/categories/als-block/"}],"tags":[{"name":"als-block","slug":"als-block","permalink":"https://alisdon.github.com/tags/als-block/"}]},{"title":"als-block-menu 使用说明","slug":"als-block-crud/menu","date":"2020-07-16T09:41:49.000Z","updated":"2022-08-10T14:02:57.763Z","comments":true,"path":"als-block/als-block-crud/menu/","link":"","permalink":"https://alisdon.github.com/als-block/als-block-crud/menu/","excerpt":"","text":"菜单篇Als-Block-Crud对菜单进行了二次封装，意为开发带来更多的便利，减少开发时多余代码的Ctrl+c、Ctrl+v。 功能说明 自动识别子级 props 对象1234567891011menuMap: &#123; options: &#123;&#125;, lisenters: &#123;&#125;, menuData: []&#125;props: &#123; path: 'path', name: 'name', icon: 'icon', children: 'children'&#125; options为element-ui中el-menu的属性，可传入Object也可以传入返回Object的Function. lisenters为element-ui中el-menu的事件，可传入Object也可以传入返回Object的Function. props 为字端映射，可在返回的数据与默认字端不一致时使用 菜单数据 属性名 说明 默认值（接收值） path 路由地址 name 菜单名称 icon 菜单图标 children 子级菜单 案例12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;als-block-menu ref='mainMenu' :menu-map='menuMap'&gt;&lt;/als-block-menu&gt;&lt;/template&gt;&lt;script&gt;export default &#123; name: 'AlsBlockMenu', data () &#123; return &#123; menuMap: &#123; options: &#123; defaultActive: '/index' &#125;, listeners: &#123; select: path =&gt; this.$router.push(path) &#125;, menuData: [&#123; path: '/index', title: '首页', icon: 'el-icon el-icon-s-grid', children: [&#123; path: '/subIndex', title: '二级菜单', icon: 'el-icon el-icon-message-solid', &#125;] &#125;, &#123; path: '/user', title: '用户管理', icon: 'el-icon el-icon-eleme' &#125;] &#125; &#125; &#125;&#125;&lt;/script&gt;","categories":[{"name":"als-block","slug":"als-block","permalink":"https://alisdon.github.com/categories/als-block/"}],"tags":[{"name":"als-block","slug":"als-block","permalink":"https://alisdon.github.com/tags/als-block/"}]},{"title":"docker 镜像","slug":"docker镜像","date":"2020-04-13T15:33:11.000Z","updated":"2020-10-19T10:02:37.082Z","comments":true,"path":"docker/docker镜像/","link":"","permalink":"https://alisdon.github.com/docker/docker镜像/","excerpt":"","text":"mysql获取镜像1docker pull mysql 运行容器12345678docker run-d-v $PWD/mysql/conf:/etc/mysql/conf.d-v $PWD/mysql/logs:/logs-v $PWD/mysql/data:/var/lib/mysql-e MYSQL_ROOT_PASSWORD=root-p 13306:3306mysql $PWD 为当前目录，设置时换成真实路径 -d：在后台运行 -p：容器的 3306 端口映射到宿主机 13306 -v：容器的 /etc/mysql/conf.d 配置文件映射到宿主机 $PWD/mysql/conf -e：mysql root 用户的密码 navicat连接查看加密特性 1select Host,User,plugin from mysql.user; 如出现以下情况 Host User plugin % root caching_sha2_password 则执行 1ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'root'; 最后的root为账号密码 设置成功后就可以进行navicat连接 mongodb获取镜像1docker pull mongo 运行容器123456docker run -d -v $PWD/mongodb/db:/data/db -p 27017:27017 --name mongodb mongo -d：在后台运行 -v：容器的 /data/db 数据配置文件映射到宿主机 $PWD/mongodb/db -p：容器的 27017 端口映射到宿主机 27017 –name：容器的名字为 mongodb jenkins获取镜像1docker pull jenkins/jenkins 运行容器123456docker run -d -v $PWD/jenkins:/var/jenkins_home -p 13050:8080--name jenkins jenkins/jenkins 与上面的说明一致 进入容器1docker exec -it [CONTAINER ID] /bin/bash 访问地址1http://localhost:13050 gitlab获取镜像1docker pull gitlab/gitlab-ce 镜像较大(1G左右),需要耐心等待 运行容器1234567891011$ docker run -d -p 443:443 # 把容器的http端口443映射到外部443端口-p 8008:80 # 把容器的web端口80映射到外部80端口-p 22:22 # 把容器的ssh端口22映射到外部22端口--name gitlab --restart always -v $PWD/config:/etc/gitlab -v $PWD/logs:/var/log/gitlab -v $PWD/data:/var/opt/gitlab gitlab/gitlab-ce –restart 设置重启方式，always 代表一直开启，服务器开机后也会自动开启的其他的与上面的说明一致 1docker ps 可以看到 GitLab 已经在运行了，其他有一个属性 STATUS 为 health: starting，说明 gitlab 的服务正在启动中，还没有启动完毕。等这个状态变成 healthy 时则说明已经部署完成，可以访问了 配置 如果出现 502 错误 1docker exec -it gitlab update-permissions 修改$PWD/gitlab/etc/gitlab.rb 123456# 配置http协议所使用的访问地址,不加端口号默认为80external_url 'http://192.168.0.101'# 配置ssh协议所使用的访问地址和端口gitlab_rails['gitlab_ssh_host'] = '192.168.0.101'gitlab_rails['gitlab_shell_ssh_port'] = 222 # 此端口是run时22端口映射的222端口 修改$PWD/gitlab/data/gitlab-rails/etc/gitlab.yml 123456789找到关键字 * ## Web server settings * 将host的值改成映射的外部主机ip地址和端口## GitLab settingsgitlab: ## Web server settings (note: host is the FQDN, do not include http://) host: 192.168.0.101 port: 22 https: false 因为是容器，所以要进入到gitlab容器中执行命令 12345docker exec -ti gitlab /bin/bashgitlab-ctl reconfigure # 修改配置gitlab-ctl restart # 重启gitlab-ctl status 访问地址1http://192.168.0.101:8008 nginx获取镜像1docker pull nginx 运行容器1docker run -d -p 80:80 --name nginx nginx 将容器中 nginx 的配置文件复制到 . 当前目录下 1docker cp nginx:/etc/nginx . 修改配置文件后即可停止并删除 nginx 服务 12docker stop nginxdocker rm nginx 目录映射 —- 使修改的配置生效 123456docker run-d-v $PWD/nginx:/etc/nginx-v $PWD/nginx/html:/usr/share/nginx/html-p 80:80nginx 与上面的说明一致 访问地址1http://localhost docker常用命令123456789docker images // 查看已有的docker镜像docker ps // 查看所有运行中容器docker ps -a // 查看所有状态的容器docker start [ID] // 启动指定ID容器docker stop [ID] // 停止指定ID容器docker restart [ID] // 重启指定ID容器docker rm [ID] // 删除指定ID容器docker rmi [NAME] // 删除特定镜像docker exec -it [CONTAINER ID] /bin/bash //进入容器 docker后私有服务部署推送注册阿里云账号并进入容器镜像服务 创建命名空间 创建镜像仓库 点击镜像仓库名称进入基本信息 本地打包docker镜像 1docker build -t demo . 根据仓库的基本信息描述将镜像推送到Registry 推送成功后切换至菜单镜像版本查看镜像信息,如果存在推送的版本信息则说明推送成功 拉取登录私有服务器 从Registry中拉取镜像 1docker pull registry.cn-hangzhou.aliyuncs.com/demo_alisdon/demo:[镜像版本号] 远程运行 1docker run -d -p 80:80 registry.cn-hangzhou.aliyuncs.com/demo_alisdon/demo:latest &gt; 待验证","categories":[{"name":"docker","slug":"docker","permalink":"https://alisdon.github.com/categories/docker/"}],"tags":[{"name":"docker基础","slug":"docker基础","permalink":"https://alisdon.github.com/tags/docker基础/"}]},{"title":"微信小程序和移动网页的相爱相杀","slug":"微信小程序和移动网页的相爱相杀","date":"2020-03-18T13:07:16.000Z","updated":"2020-03-18T15:46:37.893Z","comments":true,"path":"小程序/微信小程序和移动网页的相爱相杀/","link":"","permalink":"https://alisdon.github.com/小程序/微信小程序和移动网页的相爱相杀/","excerpt":"","text":"两者身为同一个时代的产物，存在太多志同道合、“异性相吸”的魔力，又有着不拘一格、“同性相斥”的魅力。但可以确定的是，两者身上都有一种为了实现世界统一的魄力。 生死之战 pk 项 h5 mp-weixin 运行环境 浏览器 微信 系统API权限 弱 强 分享朋友圈 能 不能 扫码识别 能 能 支付能力 多种 微信支付 使用流畅/平滑 一般 良好 入口数量 少 多 专属入口 无 有 简易功能成本 低 低 系统功能成本 高 低 迭代周期 短 较长 外部限制 较少 多 跨界合作准备工作 注册小程序账号必须为企业的，个人类型的小程序暂不支持使用 微信 6.7.2 版本以上(目前安卓最新版 7.0.12/苹果 7.0.11) 需登录小程序管理后台配置业务域名 基础库1.6.4以上 命令部署 业务域名中配置的就是小程序以及 H5 和 H5 中引用 iframe 的域名 将校验文件放置在将要嵌套的业务域名的根目录 统一战线 嵌入的 h5 不能调用支付接口 嵌入的 h5 拿不到分享成功失败的信息 互帮互助 mp -&gt; h5 使用 src 地址传值 h5 -&gt; mp postMessage, web-view 绑定 bindmessage 进行接收 weixinjssdk tips: bindMessage为网页向小程序 postMessage 时，会在特定时机（小程序后退、组件销毁、分享）触发并收到消息 矛盾冲突","categories":[{"name":"小程序","slug":"小程序","permalink":"https://alisdon.github.com/categories/小程序/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://alisdon.github.com/tags/小程序/"}]},{"title":"text-align 两端对齐","slug":"text-align-两端对齐","date":"2020-02-13T15:33:11.000Z","updated":"2020-02-13T15:47:17.790Z","comments":true,"path":"css/text-align-两端对齐/","link":"","permalink":"https://alisdon.github.com/css/text-align-两端对齐/","excerpt":"","text":"### 简单总结都知道想实现两端对齐可以使用 text-align:justify，但是每次使用或多或少都会出现一些问题。对于这些问题我们就来总结一下 1text-align: justify； 兼容性好，能兼容 ios，但只针对非尾行即最后一行之前的文本 1text-align-last: justify； 兼容性差，不兼容 ios，只针对尾行的文本 1white-space: nowrap; 设置该属性后不生效 只有一行的时候那就需要特殊的处理一下了 使用 text-align-last 手动添加一行最为最后行，并将其隐藏 小程序端实现wxml 1234567891011&lt;view class=\"foods\"&gt; &lt;view class=\"eat\"&gt; &lt;view&gt;早上吃什么&lt;text&gt;&lt;/text&gt;&lt;/view&gt;: 洗衣粉 &lt;/view&gt; &lt;view class=\"eat\"&gt; &lt;view&gt;午餐呢&lt;text&gt;&lt;/text&gt;&lt;/view&gt;: 肥皂 &lt;/view&gt; &lt;view class=\"eat\"&gt; &lt;view&gt;最重要的晚餐&lt;text&gt;&lt;/text&gt;&lt;/view&gt;: 沐浴露 &lt;/view&gt;&lt;/view&gt; wxss 123456789101112131415161718.eat &#123; line-height:100rpx&#125;.eat + .eat &#123; border-top:1rpxsolid #f5f5f5&#125;.eat view &#123; height:100rpx; width:240rpx; display: inline-block; text-align:justify; vertical-align:top&#125;.eat view text &#123; display: inline-block; height:0; width:100% /* 换行 */&#125;","categories":[{"name":"css","slug":"css","permalink":"https://alisdon.github.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://alisdon.github.com/tags/css/"}]},{"title":"mac 创建 svn 仓库","slug":"mac 创建 svn 仓库","date":"2020-01-19T02:35:49.000Z","updated":"2020-09-22T01:45:47.414Z","comments":true,"path":"其他/mac 创建 svn 仓库/","link":"","permalink":"https://alisdon.github.com/其他/mac 创建 svn 仓库/","excerpt":"","text":"团队开发中代码版本管理是一个必不可少的工具，本篇文章将简单介绍如何在 macOS 中搭建 svn 版本服务 安装 svn检查安装开始之前，先检查系统中是否已经安装了 svn 1svn --version 如果出现版本信息，则表示已经安装成功，可跳过以下安装步骤至创建仓库 开始安装在 macOS 中，一般我建议使用 Homebrew 进行包管理，至于 Homebrew 本篇文章不做描述，不了解的可以自行百度 1brew install svn 安装成功后，建议再检查安装一次，以确保能够正常使用 创建仓库在安装成功之后咱们就可以创建代码仓库了 1svnadmin create ./svn/repository/svn_test ./svn/repository/svn_test 为你想存放 svn 仓库的文件地址，svn_test 为当前仓库名称，这里换成你自己的即可 正常情况下，你将可以在你刚刚输入的目录中看到新生成的文件夹了，但是 macOS 升级成 macOS catalina 10.15 后将会出现 1zsh: command not found: svnadmin 这个是因为 Apple 在这个版本中移除了 svn 管理，所以导致了 svn 相关的命令失效，这里多说一句 Apple 的这个更新可能会导致一部分的软件需要重新安装，如果遇到了不能正常使用的软件，大家不妨重新安装试一试 配置权限安装成功后，进入到你刚刚设置的目录中，如我们设置的 ./svn/repository/svn_test，你将看见大致（只展示我们需要的部分）如下的目录 12345678910|-- conf|---- authz|---- hooks-env.tmpl|---- passwd|---- svnserve.conf|-- db|-- hooks|-- locks|-- format|-- README.txt 权限打开 conf 下的 svnserve.conf 文件并做以下修改 1234567891011# anon-access = readanon-access = read# auth-access = writeauth-access = write# password-db = passwdpassword-db = passwd# authz-db = authzauthz-db = authz 以上修改为上一行为原始配置，下一行为修改后的配置 以上配置信息的含义请自行百度 用户打开 conf 下的 passwd 文件并做以下修改 1234[users]svnuser1 = 123456svnuser2 = 123456 添加用户名为 svnuser1，密码为 123456 和用户名为 svnuser2，密码为 123456 的两位用户 分组授权打开 conf 下的 authz 文件并做以下修改 12345[groups]svngroup = svnuser1,svnuser2[/]@svngroup=rw rw为可读可写 启动服务返回控制台输入 1svnserve -d -r ./svn/repository 这里需要控制所建仓库地址，不需要进行至仓库名称 如果控制台没有报错则说明启动成功 连接服务启动成功后，我们将远程的代码进行拉去，尽管现在没有代码，我们也可以先将仓库拉下来用于后续代码管理 1svn checkout svn://localhost/svn_test --username=svnuser1 --password=123456 ./code 将代码从 svn_test 下载到 ./code 目录下 关闭服务因为 svn 服务就是一个进程，所以可以通过杀进程的方式进行管理 方法一（推荐）：打开系统软件《活动监视器》 选择 svnserve 进行关闭即可。 方法二获取 svn 的 PID 1ps -ef|grep svn 杀掉进程 1kill -9 $1 $1 为上面获取到的 PID 至此这样一个 svn 代码管理仓库就搭建完成了，我们就可以用 svn 来进行我们的代码管理","categories":[{"name":"其他","slug":"其他","permalink":"https://alisdon.github.com/categories/其他/"}],"tags":[{"name":"svn","slug":"svn","permalink":"https://alisdon.github.com/tags/svn/"}]},{"title":"uni-app","slug":"uni-app踩过的坑","date":"2019-03-24T06:43:01.000Z","updated":"2019-03-27T15:11:21.816Z","comments":true,"path":"混合开发/uni-app踩过的坑/","link":"","permalink":"https://alisdon.github.com/混合开发/uni-app踩过的坑/","excerpt":"","text":"在uni-app进行多端开发总结H5非H5 不可对uni进行属性添加 不可使用slot属性 不可上传非图片文件 微信小程序支付宝小程序 不可使用高度100% 需要将导航栏的背景设置成#fff才可以显示标题","categories":[{"name":"混合开发","slug":"混合开发","permalink":"https://alisdon.github.com/categories/混合开发/"}],"tags":[{"name":"uni-app","slug":"uni-app","permalink":"https://alisdon.github.com/tags/uni-app/"}]},{"title":"小程序获取特定页二维码","slug":"小程序获取特定页二维码","date":"2019-01-04T05:55:37.000Z","updated":"2019-01-04T06:10:27.680Z","comments":true,"path":"小程序/小程序获取特定页二维码/","link":"","permalink":"https://alisdon.github.com/小程序/小程序获取特定页二维码/","excerpt":"","text":"准备工作 确保页面路径存在app.json文件中 获取小程序的AppId和AppSecret 下载postman工具 开始获取微信提供了「获取小程序二维码」的接口。通过这个接口，商家和开发者能够制作进入不同页面的小程序二维码，而不会限定扫码进入小程序主页。 获取Access Token利用postman工具根据准备的AppID和AppSecret，获取 Access Token。 使用get方式请求地址https://api.weixin.qq.com/cgi-bin/token，传入以下参数 12345&#123; grant_type: client_credential, appid: 你的AppId, secret: 你的AppSecret&#125; 点击Send出现图中所示则表示请求成功，其中access_token就是我们需要的值 获取二维码微信提供了两个POST获取小程序二维码的接口 获取最新的「菊花式」小程序码，可以使用这个接口： 1https://api.weixin.qq.com/wxa/getwxacode?access_token=ACCESS_TOKEN。 获取经典的「狗皮膏药式」QR 码，可以使用这个接口： 1https://api.weixin.qq.com/cgi-bin/wxaapp/createwxaqrcode?access_token=ACCESS_TOKEN 在postman中输入以上地址后需要修改POST请求体中的请求方式为raw, 并修改JSON请求体为 1&#123;\"path\": \"pages/discover/article/index?type=1\"&#125; 最终配置如下 如果请求成功则会返回小程序的二维码图片","categories":[{"name":"小程序","slug":"小程序","permalink":"https://alisdon.github.com/categories/小程序/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"https://alisdon.github.com/tags/微信小程序/"}]},{"title":"用vertical-align实现垂直水平居中","slug":"verticalAlign简介","date":"2019-01-02T08:07:16.000Z","updated":"2019-01-04T01:33:13.544Z","comments":true,"path":"css/verticalAlign简介/","link":"","permalink":"https://alisdon.github.com/css/verticalAlign简介/","excerpt":"","text":"简介vertical-align属于css中用的比较少的一个属性，其原因就是它比较难于理解，但它是同时也是一个比较重要的属性。首先引用一段对它的定义说明 该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。允许指定负长度值和百分比值。这会使元素降低而不是升高。在表单元格中，这个属性会设置单元格框中的单元格内容的对齐方式。 对此我们得到了两层重要信息 该属性定义行内元素的基线相对于该元素所在行的基线的垂直对齐。注意其中的行内元素，说明该属性只对行内元素有效 表格的td中直接添加vertical-align: middle的样式让其垂直居中对齐，添加vertical-align: top顶部对齐。 Tips: 该属性与水平对齐方式属性text-align不同，使用对象是linebox下的行内元素 什么是Line Box 每一行称为一条Line Box，它又是由这一行的许多inline-box组成，它的高度可以直接由line-height决定，line boxes的高度垂直堆叠形成了containing box的高度，就是我们见到的div或是p标签之类的高度了 baseline传送门 实际应用垂直居中 为父元素设定一个伪元素::after,其高度为父元素的高度并设置display:inline-block让其成为lineBox元素,将::after设定为vertical-align:middle即可撑开lineBox，同时lineBox的baseline为父元素高度一半的位置。然后设定子元素vertical-align:middle，即可实现居中。 考虑兼容性的话，这里需要使用一些hack，由于IE8不支持::after伪元素，所以需要一个span来替代。而display:inline-block亦需要hack。 代码示例： 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;style&gt; .masker-model &#123; background-color: #000; opacity: .6; z-index: 999; position: fixed; left: 0; right: 0; top: 0; bottom: 0; text-align: center; &#125; .masker-model::after &#123; content: ''; display: inline-block; height: 100%; vertical-align: middle; &#125; .loading &#123; color: #fff; display: inline-block; vertical-align: middle; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=\"masker-model\"&gt; &lt;div class=\"loading\"&gt;loading....&lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"css","slug":"css","permalink":"https://alisdon.github.com/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://alisdon.github.com/tags/css/"}]},{"title":"创建简单的npm脚手架","slug":"创建简单的npm脚手架","date":"2018-12-18T08:57:18.000Z","updated":"2019-02-13T02:46:16.038Z","comments":true,"path":"服务端/创建简单的npm脚手架/","link":"","permalink":"https://alisdon.github.com/服务端/创建简单的npm脚手架/","excerpt":"","text":"前言vue-cli， webpack-cli 等脚手架是不是用起来爱不释手？自己写了个模版每次来回复制粘贴代码是不是很难维护？如果你是对前端、Node操作有一定的了解，同时也存在以上疑问，那就请尽情阅读尝试吧！ 本篇文章按照al-block-cli举例, al-block-cli是一个基于vue和elementUI而集成的一个开发模版，可安装进行使用 依赖 Commander.js 命令行工具 download-git-repo git仓库代码下载 chalk 命令行输出样式美化 Inquirer.js 命令行交互 ora命令行加载中效果 根据上方的依赖插件即可以看出，其实脚手架就是一个利用终端命令将仓库中的代码拉取到本地的工具。所以还没有模版代码的同学赶紧去创建个 项目准备Npm初始化1$ npm init 根据提示完成初始化搭建，如果不清楚如何配置可以直接回车 安装依赖1$ npm install commander download-git-repo chalk inquirer ora --save 构建结构 创建bin和commands文件夹以及配置文件templates.json。 在bin目录下创建入口文件al-block-cli，在commands目录下创建命令指示文件init.js bin文件夹为可执行命令入口目录，commands则负责编写一些命令交互， 最终目录结构12345678- al-block-cli| - bin | - al-blocl-cli| - commands | - init.js| - node_modules| - package.json| - templates.json 编写代码配置文件输入默认需要的配置，如这里需要github的仓库地址和命令行的名称 123456&#123; \"init\": &#123; \"name\": \"init\", \"path\": \"Alisdon/al-block-template\" &#125;&#125; 入口文件打开al-block-cli文件，并在其第一行加入 1#! /usr/bin/env node 此行为了防止操作系统用户没有将node装在默认的/usr/bin路径里。当系统看到这一行的时候，首先会到env设置里查找node的安装路径，再调用对应路径下的解释器程序完成操作。 123456789101112131415161718192021222324#!/usr/bin/env nodeprocess.env.NODE_PATH = __dirname + '/../node_modules/';const program = require('commander');program .version(require('../package').version);program .usage('&lt;command&gt;');program.command('init') .description('create a new project') .alias('i') .action(() =&gt; &#123; require('../commands/init') &#125;);program.parse(process.argv);if(!program.args.length)&#123; program.help()&#125; 命令交互打开表示命令init的init.js文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192const &#123; prompt &#125; = require('inquirer');const program = require('commander');const chalk = require('chalk');const download = require('download-git-repo');const ora = require('ora');const fs = require('fs');const option = program.parse(process.argv).args[0];const question = [ &#123; type: 'input', name: 'name', message: 'Project name', default: typeof option === 'string' ? option : 'al-block-template', filter (val) &#123; return val.trim() &#125;, validate (val) &#123; const validate = (val.trim().split(\" \")).length === 1; return validate || 'Project name is not allowed to have spaces '; &#125;, transformer (val) &#123; return val; &#125; &#125;, &#123; type: 'input', name: 'description', message: 'Project description', default: 'Vue project', validate () &#123; return true; &#125;, transformer(val) &#123; return val; &#125; &#125;, &#123; type: 'input', name: 'author', message: 'Author', default: '', validate () &#123; return true; &#125;, transformer(val) &#123; return val; &#125; &#125;];module.exports = prompt(question).then((&#123;name, description, author&#125;) =&gt; &#123; const gitPlace = require('../templates').init.path; const projectName = name; const spinner = ora('Downloading please wait...'); spinner.start(); download(`$&#123;gitPlace&#125;`, `./$&#123;projectName&#125;`, (err) =&gt; &#123; if (err) &#123; console.log(chalk.red(err)); process.exit() &#125; fs.readFile(`./$&#123;projectName&#125;/package.json`, 'utf8', function (err, data) &#123; if(err) &#123; spinner.stop(); console.error(err); return; &#125; const packageJson = JSON.parse(data); packageJson.name = name; packageJson.description = description; packageJson.author = author; fs.writeFile(`./$&#123;projectName&#125;/package.json`, JSON.stringify(packageJson, null, 2), 'utf8', function (err) &#123; if(err) &#123; spinner.stop(); console.error(err); &#125; else &#123; spinner.stop(); console.log(chalk.green('project init successfully!')) console.log(` $&#123;chalk.yellow(`cd $&#123;name&#125;`)&#125; $&#123;chalk.yellow('npm install')&#125; $&#123;chalk.yellow('npm run dev')&#125; `); &#125; &#125;); &#125;); &#125;)&#125;); 测试发布测试至此，一个简单的脚手架（壳）就已经完成了，为了查看在编写过程中是否出错，我们现在本地进行测试 1$ node bin/al-block-cli 如果没有报错，出现了熟悉的命令行，那就说明成功了 发布发布之前我们需要做个小调整，观察其他脚手架工具他们都是以自己独特的key值进行搭建，对此我们可以在package.json里面配置bin对象 123\"bin\": &#123; \"al-block-cli\": \"bin/al-block-cli\"&#125; 这里需要注意bin/后面的al-block-cli,这个路径是由入口文件的路径确定，如果你是建的al-block-cli.js则此处应该配置bin/al-block-cli.js，本篇是创建的没有后缀名的文件 修改后生成的最终package.json 1234567891011121314151617181920212223242526&#123; \"name\": \"al-block-cli\", \"version\": \"1.0.0\", \"description\": \"al-block-cli\", \"keywords\": [ \"vue\", \"al-block\", \"al-block-cli\" ], \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"bin\": &#123; \"al-block-cli\": \"bin/al-block-cli\" &#125;, \"preferGlobal\": true, \"author\": \"Alisdon [920124512@qq.com]\", \"license\": \"MIT\", \"dependencies\": &#123; \"chalk\": \"^2.4.1\", \"commander\": \"^2.19.0\", \"download-git-repo\": \"^1.1.0\", \"inquirer\": \"^6.2.1\", \"ora\": \"^3.0.0\" &#125;&#125; 对比文件内容，如果没有问题我们就开始发布了 12$ npm login$ npm publish","categories":[{"name":"服务端","slug":"服务端","permalink":"https://alisdon.github.com/categories/服务端/"}],"tags":[{"name":"node","slug":"node","permalink":"https://alisdon.github.com/tags/node/"}]},{"title":"用于mmzsblog网站博客开发","slug":"mmzsblog","date":"2018-11-20T13:07:16.000Z","updated":"2022-08-03T14:23:55.220Z","comments":true,"path":"mmzsblog/mmzsblog/","link":"","permalink":"https://alisdon.github.com/mmzsblog/mmzsblog/","excerpt":"","text":"前期准备以下代码均在系统命令行(非node环境下的命令行)下完成。 cmd打开window系统命令行 直接在mac系统中打开终端 安装nodeJs前往 node官方下载地址下载对应版本进行安装 检测安装状态1$ node -v 出现版本信息则表示安装成功 安装git前往 git官方下载地址下载对应版本进行安装 检测安装状态1$ git --version 出现版本信息则表示安装成功 安装hexo1$ npm install -g hexo-cli 此步骤需要将nodejs安装成功后才可进行，否则将报npm命令不存在的错误 检测安装状态1$ hexo version 出现版本信息则表示安装成功 克隆代码克隆框架代码1$ git clone git@118.24.19.22:/mmzsblog/blog.git 此步骤需要将git安装成功后才可进行，否则将报git命令不存在的错误。后续在新增文章之前需要先更新框架代码。拉取成功后默认文件夹名称为blog，本篇文章以blog为文件夹名称举例 克隆主题代码12$ cd blog$ git clone git@118.24.19.22:/mmzsblog/theme.git themes/pure 此步骤需要将git安装成功后才可进行，否则将报git命令不存在的错误，由于框架代码中主题代码不能提交成功，所以将其分开获取。此代码只需要拉取一次，后续新增文章之前可不再更新 安装依赖1$ npm install 执行成功上述操作将出现图中目录文件 开始创建新建文章创建文章之前先更新仓库代码，然后再创建一篇新文章 12$ git pull$ hexo new 你的文章名称 打开当前文件夹下的source/_post目录，找到新建的文件（一般是根据上方新建的文章名称作为文件名称）进行编写 静态图片的处理 放到source/images文件中，在文章中需要进行![](/images/xxx.jpg)的引入 直接放到和文章名称相同的文件夹中，在文章中需要进行![](./xxx.png)的引入 预览文章1$ hexo server 简写 hexo s 打开浏览器输入http://localhost:4000进行访问。如果出现白板且控制台出现了index.html相关的问题则是由于没有获取主题导致的，需要前往克隆主题文件 发布文章由于mmzsblog是通过github进行重定向，所以将不做清理静态文件的操作，避免提交后需要重新设置的重复操作 打包编译12$ git pull$ hexo generate 简写 hexo g 发布提交1$ hexo deploy 简写 hexo d 如果出现以上提示则说明提交成功，隔几分钟后刷新https://blog.mmzsblog.cn即可查看刚刚新增的文章 提交代码提交框架代码，避免多人开发时不同步的问题 1234$ git status$ git add .$ git commit -m '新增一篇文章'$ git push","categories":[{"name":"mmzsblog","slug":"mmzsblog","permalink":"https://alisdon.github.com/categories/mmzsblog/"}],"tags":[{"name":"mmzsblog","slug":"mmzsblog","permalink":"https://alisdon.github.com/tags/mmzsblog/"}]},{"title":"mac下安装nginx","slug":"mac 下安装nginx","date":"2018-10-19T06:14:37.000Z","updated":"2019-01-04T01:37:27.439Z","comments":true,"path":"服务端/mac 下安装nginx/","link":"","permalink":"https://alisdon.github.com/服务端/mac 下安装nginx/","excerpt":"","text":"初识nginx相信大多数同学已经听说了nginx这个东东，会不会很多同学和我一样一开始接触nginx的时候不知道它是什么？它能干什么？如果需要启服务，完全可以用node，为什么还需要使用nginx？ 对以上问题，我先引用一下官方对nginx的介绍 “Nginx是一款轻量级的HTTP服务器，采用事件驱动的异步非阻塞处理方式框架，这让其具有极好的IO性能，时常用于服务端的反向代理和负载均衡。” nginx的应用场景 http服务器。Nginx是一个http服务可以独立提供http服务。可以做网页静态服务器。 虚拟主机。可以实现在一台服务器虚拟出多个网站。例如个人网站使用的虚拟主机。 反向代理，负载均衡。当网站的访问量达到一定程度后，单台服务器不能满足用户的请求时，需要用多台服务器集群可以使用nginx做反向代理。并且多台服务器可以平均分担负载，不会因为某台服务器负载高宕机而某台服务器闲置的情况。 nginx的优点nginx的优点在应用场景中已有体现，比如上面提到的反向代理，负载均衡功能。除此之外还有以下优势 支持海量高并发：采用IO多路复用epoll。官方测试Nginx能够支持5万并发链接，实际生产环境中可以支撑2-4万并发连接数。 内存消耗少：在主流的服务器中Nginx目前是内存消耗最小的。 配置文件简单：网络和程序配置通俗易懂，即使非专业运维也能看懂。 支持热部署：这对于我们前端的同学来说，使用惯webpack的热更新，对热更新的支持，无疑是吸引了一大波同学（我就算其中一个，啊哈哈） 安装nginx前面铺垫了这么多，现在终于进入主题了。本教程是使用homebrew进行安装，未安装brew的同学请自行安装 brew install nginx 配置文件地址安装成功后需要对配置文件进行个性化定制，本教程提供大部分时间需要修改的配置，配置文件在如下地址处 /usr/local/etc/nginx/nginx.conf 默认根目录是否想知道网址访问的哪份文件呢？来，我们一起打开它 /usr/local/var/www/ 启动重启关闭成功安装后，我们肯定就是来使用nginx了，你可使用 nginx 直接启动或者使用 nginx -s reload|reopen|stop|quit 重新加载配置|重启|快速停止|安全关闭 启动成功后，我们就只需要在浏览器中访问服务（地址）就好了 http://localhost:8080 自定义配置修改访问端口默认8080被占用了？或者你看8080端口不爽？来，我们一起灭了它 修改默认根目录修改完8080，你是否觉得用默认的网站根目录很难找？是不是想换成自己熟悉的目录呢？ tips: 配置文件里location / 里面的root,将yourname换成你电脑的用户名 异常处理Permission问题这种问题都是没有权限引起的，执行代码前加上sudo即可 Forbidden修改了默认的网站根目录，出现问题时避免不了的。但是怎么办呢？这种问题一般是没有找到对应的文件，要不就是权限的问题 查看目录下是否存在index.html或者index.htm 修改配置文件第一行为 user root owner; 然后重启 File not find同上 Forbidden 的解决方案 卸载nginx好了，最后，如果你还是觉得nginx用起来不爽，更喜欢node，Apache什么的，勇敢的卸载它吧 brew uninstall nginx","categories":[{"name":"服务端","slug":"服务端","permalink":"https://alisdon.github.com/categories/服务端/"}],"tags":[{"name":"nginx","slug":"nginx","permalink":"https://alisdon.github.com/tags/nginx/"}]},{"title":"安装hexo","slug":"安装hexo","date":"2018-07-27T16:12:50.132Z","updated":"2018-12-19T04:19:14.333Z","comments":true,"path":"其他/安装hexo/","link":"","permalink":"https://alisdon.github.com/其他/安装hexo/","excerpt":"","text":"安装hexo1$ npm install -g hexo-cli 初始化项目123$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install`` 启动项目1$ hexo server 更换主题选择喜欢的主题并根据选择的主题进行更换，并将_config.yml中的theme主题替换成在文件夹theme中的文件名称, 添加主题中需要的图片等素材","categories":[{"name":"其他","slug":"其他","permalink":"https://alisdon.github.com/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://alisdon.github.com/tags/其他/"}]},{"title":"hexo书写一篇文章","slug":"用hexo写一篇文章","date":"2018-07-27T16:12:50.110Z","updated":"2018-12-19T04:19:36.194Z","comments":true,"path":"其他/用hexo写一篇文章/","link":"","permalink":"https://alisdon.github.com/其他/用hexo写一篇文章/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate (hexo g) More info: Generating Deploy to remote sites1$ hexo deploy (hexo d) More info: Deployment","categories":[{"name":"其他","slug":"其他","permalink":"https://alisdon.github.com/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"https://alisdon.github.com/tags/其他/"}]},{"title":"linux下实现无密操作git","slug":"linux下实现无密操作git","date":"2018-07-24T08:44:46.000Z","updated":"2019-01-04T01:37:37.189Z","comments":true,"path":"服务端/linux下实现无密操作git/","link":"","permalink":"https://alisdon.github.com/服务端/linux下实现无密操作git/","excerpt":"","text":"linux服务端配置linux安装git yum install -y git 创建用户git groupadd git adduser git -g git 配置linux权限问题及创建authorized_keys文件 cd /home/git mkdir .ssh chmod 700 .ssh touch .ssh/authorized_keys chmod 600 .ssh/authorized_keys cd /home chown -R git:git git Tips:后续的git clone如果需要密码，很有可能是git用户没有访问authorized_keys文件的权限 创建git仓库文件夹 cd /home mkdir gitTest chown git:git gitTest //赋予git用户权限 初始化git仓库 cd gitTest git init --bare gitTest.git 把仓库所属用户改为git chown -R git:git gitTest.git 创建post-receive文件（若不使用git自启动属性可不操作） vim ~/gitTest.git/hooks/post-receive post-receive文件内容（若不使用git自启动属性可不操作） #！/bin/sh git --work-tree=/usr/share/nginx/html/blog --git-dir=/home/gitTest/gitTest.git checkout -f 设置权限（若不使用git自启动属性可不操作） chmod +x ~/gitTest.git/hooks/post-receive 创建客户端口令ssh-keygen -t rsa -C &apos;你的邮箱&apos; 设置免密登录口令将id_rsa.pub中的内容写到服务器的authorized_keys文件中。 cat id_rsa.pub &gt;&gt; authorized_keys 请求git仓库git clone git@ip:/home/gitTest/gitTest.git","categories":[{"name":"服务端","slug":"服务端","permalink":"https://alisdon.github.com/categories/服务端/"}],"tags":[{"name":"git","slug":"git","permalink":"https://alisdon.github.com/tags/git/"}]}]}